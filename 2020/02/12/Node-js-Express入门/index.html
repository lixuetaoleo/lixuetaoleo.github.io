<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta charset="UTF-8"><title>Node.js/Express入门 | Li Xuetao</title><link rel="stylesheet" href="/css/temp.css"><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Lato|Source+Sans+Pro&display=swap" rel="stylesheet"></head><body><div id="layout-page"><nav id="layout-menu"><div class="other-page hide"><a href="/about">About</a><a href="/archives">Archives</a></div><div class="responsive-pad"></div><div id="mega-head"><a href="/">LI XUETAO</a></div><div class="layout-socialmedia hide"><a class="link-item main-link-item" title="Instagram" href="https://www.instagram.com/lixuetaoleo/"><i class="iconfont icon-instagram"></i></a><a class="link-item main-link-item" title="Twitter" href="https://twitter.com/lixuetaoleo"><i class="iconfont icon-twitter"></i></a><a class="link-item main-link-item" title="Weibo" href="https://weibo.com/u/1791741344"><i class="iconfont icon-weibo"></i></a><a class="link-item main-link-item" title="GitHub" href="https://github.com/lixuetaoleo"><i class="iconfont icon-github"></i></a></div><div class="responsive-bar" onclick="toggle(this)">≡</div></nav><div id="content"><article id="post"><h1>Node.js/Express入门</h1><time class="created-date" datetime="2020-02-12T10:22:07.000Z">2020-02-12</time><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>安装node和npm：sudo apt install -y nodejs</p>
<p> 安装完成后在终端输入node -v 和 npm -v 如果有输出说明安装成功</p>
</li>
<li><p>安装express</p>
<p> sudo npm install express-generator -g<br> -g代表全局安装，一般情况下工具都可以加-g进行全局安装</p>
</li>
</ol>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ol>
<li><p>mkdir 项目名 新建一个项目并cd至这个新建的文件夹里</p>
</li>
<li><p>express –view=pug  应用pug视图引擎生成一个项目骨架</p>
</li>
<li><p>npm install 安装所需依赖</p>
</li>
<li><p>DEBUG=express-locallibrary-tutorial:* npm start<br>以DEBUG模式运行这个项目(在命令行会有信息输出)，如果直接npm start则不会有信息输出</p>
</li>
<li><p>在浏览器键入<code>http://localhost:3000/</code>，可以看到默认的信息</p>
</li>
<li><p>一个trick–项目在进行了文件改动之后自动刷新重启</p>
<ol>
<li>利用nodemon，安装：sudo npm install -g nodemon</li>
<li>还可以把它作为开发依赖将安装在本地，于是使用这个项目的开发人员只要安装这个应用就能自动获得：<ol>
<li>npm install –save-dev nodemon</li>
<li>项目的 package.json 文件将自动添加一个新的属性：  “devDependencies”: {“nodemon”: “^1.18.9” }</li>
<li>“scripts”: {    “start”: “node ./bin/www”,    “devstart”: “nodemon ./bin/www”  },</li>
</ol>
</li>
<li>用新建的 devstart 命令启动服务器：DEBUG=express-locallibrary-tutorial:* npm run devstart</li>
</ol>
</li>
</ol>
<hr>
<p>Express中间件的使用：</p>
<ol>
<li><p>// 用 use() 为所有的路由和动词添加该函数<br>app.use(a_middleware_function);</p>
</li>
<li><p>// 用 use() 为一个特定的路由添加该函数<br>app.use(‘/someroute’, a_middleware_function);</p>
</li>
<li><p>// 为一个特定的 HTTP 动词和路由添加该函数<br>app.get(‘/‘, a_middleware_function);</p>
</li>
</ol>
<pre><code class="JavaScript">const express = require(&#39;express&#39;);
const app = express();

// 示例中间件函数
const a_middleware_function = (req, res, next) =&gt; {
  // ... 进行一些操作
  next(); // 调用 next() ，Express 将调用处理链中下一个中间件函数。
};

// 用 use() 为所有的路由和动词添加该函数
app.use(a_middleware_function);

// 用 use() 为一个特定的路由添加该函数
app.use(&#39;/someroute&#39;, a_middleware_function);

// 为一个特定的 HTTP 动词和路由添加该函数
app.get(&#39;/&#39;, a_middleware_function);

app.listen(3000);</code></pre>
<ol>
<li><p>MongoDB 数据库里，“集合”中的“文档” 类似于 关系数据库里“表”中的“行”。</p>
</li>
<li><p>mongodb+srv://lixuetao:<a href="mailto:13579@cluster0-d9cdx.azure.mongodb.net" target="_blank" rel="noopener">13579@cluster0-d9cdx.azure.mongodb.net</a>/<br>local-library?retryWrites=true&amp;w=majority</p>
</li>
<li><p>控制器不是单个中间件函数（带参数（req, res, next）），而是指定一组中间件函数。数组传递给路由器函数，<code>并按顺序调用</code>每个方法。</p>
</li>
<li><p>trim()，以删除任何尾随/前导空格</p>
</li>
<li><p>escape()转义任何危险的 HTML 字符。</p>
</li>
<li><p>所有的 POST控制器中，都使用了相同的模式：我们运行验证器，然后运行消毒器，然后检查错误，并使用错误信息重新呈现表单，或保存数据。</p>
</li>
<li><p>可以用菊花链式连接验证器，使用withMessage()指定在前一个验证方法失败时，显示的错误消息。这使得在没有大量代码重复的情况下，提供特定的错误消息变得非常容易。</p>
</li>
<li><p>可以使用optional()函数，仅在输入字段时运行后续验证（这允许我们验证可选字段）。例如，下面我们检查可选的出生日期是否符合 ISO8601 标准（checkFalsy 旗标，表示我们接受空字符串或null作为空值）</p>
</li>
<li><p>参数从请求中作为字符串接收。我们可以使用toDate()（或toBoolean()等）将这些转换为正确的JavaScript类型。</p>
</li>
</ol>
<hr>
<hr>
<hr>
<h2 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h2><ol>
<li>Express应用的入口是app.js。路由模块、数据库连接、模板引擎设置、各种app.use(…)都在这里配置</li>
<li>appjs都是通过app这个变量来操作<pre><code class="js">const express = require(&#39;express&#39;);
const app = express();
app.use()...
app.set()...</code></pre>
<pre><code class="js">//连接mongodb
const mongoose = require(&#39;mongoose&#39;);
const mongoDB = &#39;mongodb+srv://lixuetao:13579@cluster0-d9cdx.azure.mongodb.net/local-library?retryWrites=true&amp;w=majority&#39;;
mongoose.connect(mongoDB, { useNewUrlParser: true });
const db = mongoose.connection;
db.on(&#39;error&#39;, console.error.bind(console, &#39;MongoDB connection error:&#39;));</code></pre>
</li>
</ol>
<hr>
<h2 id="mongoose用法-Model层"><a href="#mongoose用法-Model层" class="headerlink" title="mongoose用法/Model层"></a>mongoose用法/Model层</h2><ol>
<li>在项目里创建models文件夹，所有的mongoDB的schema都放在这里。</li>
</ol>
<pre><code class="js">const mongoose = require(&#39;mongoose&#39;);
const Schema = mongoose.Schema;

const your_schema_name = new Schema({
    property_name:        
{
    type:String/Date/Number/Boolean...,
    required: true/false,
    min:...,
    max:...,
    default:...,
    enum:[],
},
//如果要引用别的schema
property_name:
{
    type: Schema.Types.ObjectId, 
    ref: &#39;Author&#39;, 
    required: true
}
});</code></pre>
<ol>
<li>可以用virtual结合几个真实属性(比如属性分为了firstname和lastname，要添加一个fullname属性用virtual就可以)</li>
</ol>
<pre><code class="js">personSchema.virtual(&#39;fullName&#39;).
  get(function() {
    return this.name.first + &#39; &#39; + this.name.last;
  }).
  set(function(v) {
    this.name.first = v.substr(0, v.indexOf(&#39; &#39;));
    this.name.last = v.substr(v.indexOf(&#39; &#39;) + 1);
  });

axl.fullName = &#39;William Rose&#39;; // Now `axl.name.first` is &quot;William&quot;</code></pre>
<ol>
<li>最后导出这个schema</li>
</ol>
<pre><code class="js">module.exports = mongoose.model(&#39;Book/Author/...&#39;, your_schema_name);</code></pre>
<ol>
<li>几个mongoose的API</li>
</ol>
<pre><code class="js">findByIdAndUpdate
findByIdAndRemove</code></pre>
<hr>
<h2 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h2><ol>
<li>controller层主要处理GET,POST等操作。首先要在routes文件夹下写路由的函数，然后传入回调各路由函数。e.g.:</li>
</ol>
<pre><code class="js">const express = require(&#39;express&#39;);
const router = express.Router();

const book_controller = require(&#39;../controllers/bookController&#39;);

router.get(&#39;/book/create&#39;, book_controller.book_create_get);
router.post(&#39;/book/create&#39;, book_controller.book_create_post);
//路由URL可以传递参数
比如：&#39;/book/:id/delete&#39;

module.exports = router;</code></pre>
<ol>
<li>controller文件夹里的函数就是各个回调函数。<ol>
<li>查找某一个Schema的内容</li>
</ol>
</li>
</ol>
<pre><code>```js
exports.author_list = function (req, res, next) {
    Author.find()
        .sort([[&#39;family_name&#39;, &#39;ascending&#39;]])
     .exec(function (err, list_authors) {
          if (err) { return next(err); }
          //Successful, so render
res.render(&#39;author_list&#39;, { title: &#39;Author List&#39;, author_list: list_authors });
    });
};
//find()不传参数找到所有的内容
//sort给排序
//exec执行回调，最后传参给模板引擎进行render,render函数的第一个参数是要render的文件名，第二个参数是给引擎传的内容。
```</code></pre><ol>
<li>查找多个schema的内容</li>
</ol>
<pre><code>```js
exports.author_detail = function (req, res, next) {
  async.parallel({
    author: function (callback) {
      Author.findById(req.params.id)
        .exec(callback)
    },
    authors_books: function (callback) {          Book.find({ &#39;author&#39;: req.params.id }, &#39;title summary&#39;)
        .exec(callback)
    },
  }, function (err, results) {
    if (err) { return next(err); } // Error in API usage.
    if (results.author == null) { // No results.
      var err = new Error(&#39;Author not found&#39;);
      err.status = 404;
      return next(err);
    }
    // Successful, so render.
    res.render(&#39;author_detail&#39;, { title: &#39;Author Detail&#39;, author: results.author, author_books: results.authors_books });
  });
};
//req.params.id获取URL传过来的ID
//async.parallel({prop:func1, prop:func2},回调)
```</code></pre><ol>
<li><p>POST的回调可以用一个数组存多个函数，按顺序执行，首先清洗，然后sanitizeBody，validationResult，最后再对req、res和next进行处理</p>
<pre><code class="js">exports.author_create_post = [
 body(&#39;first_name&#39;).isLength({ min: 1 }).trim().withMessage(&#39;first name must be specified&#39;)
   .isAlphanumeric().withMessage(&#39;First name has non-alphanumeric characters.&#39;),
 body(&#39;family_name&#39;).isLength({ min: 1 }).trim().withMessage(&#39;family name must be specified&#39;)
   .isAlphanumeric().withMessage(&#39;Family name has non-alphanumeric characters.&#39;),
 body(&#39;date_of_birth&#39;, &#39;invalid date of birth&#39;).optional({ checkFalsy: true }).isISO8601(),
 body(&#39;date_of_death&#39;, &#39;invalid date of death&#39;).optional({ checkFalsy: true }).isISO8601(),
 sanitizeBody(&#39;first_name&#39;).trim().escape(),
 sanitizeBody(&#39;family_name&#39;).trim().escape(),
 sanitizeBody(&#39;date_of_birth&#39;).toDate(),
 sanitizeBody(&#39;date_of_death&#39;).toDate(),
 (req, res, next) =&gt; {
   const errs = validationResult(req);
   if (!errs.isEmpty()) {
     res.render(&#39;author_form&#39;, { title: &#39;Create Author&#39;, author: req.body, errors: errors.array() });
     return;
   }
   else {
     const author = new Author({
       first_name: req.body.first_name,
       family_name: req.body.family_name,
       date_of_birth: req.body.date_of_birth,
       date_of_death: req.body.date_of_death,
     });
     author.save(function (err) {
       if (err)
         return next(err);
       res.redirect(author.url);
     });
   }
 }
];</code></pre>
</li>
</ol>
<hr>
<h2 id="View层"><a href="#View层" class="headerlink" title="View层"></a>View层</h2><p>express可以指定几个模板引擎：pug、ejs等，默认采用pug，也可以采用css预处理less、sass、stylus等，默认不采用预处理器。</p>
<p>这个项目用的pug，个人对pug较为熟悉，在此暂不记录</p>
</article><div id="paginator"></div></div><footer id="bottom"><span>Created By </span><a href="https://lixuetaoleo.github.io">Li Xuetao</a><span> | </span><a href="http://hexo.io"><span>HEXO</span></a></footer></div><script src="/js/temp.js"></script><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script></body></html>