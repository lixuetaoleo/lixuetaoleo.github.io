<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta charset="UTF-8"><title>Redux总结 | LI XUETAO</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Lato|Source+Sans+Pro&display=swap" rel="stylesheet"></head><body><div id="layout-page"><nav id="layout-menu"><div class="other-page hide"><a href="/about">About</a><a href="/archives">Archives</a></div><div class="responsive-pad"></div><div id="mega-head"><a href="/">LI XUETAO</a></div><div class="layout-socialmedia hide"><a class="link-item main-link-item" title="Instagram" href="https://www.instagram.com/lixuetaoleo/"><i class="iconfont icon-instagram"></i></a><a class="link-item main-link-item" title="Twitter" href="https://twitter.com/lixuetaoleo"><i class="iconfont icon-twitter"></i></a><a class="link-item main-link-item" title="Weibo" href="https://weibo.com/u/1791741344"><i class="iconfont icon-weibo"></i></a><a class="link-item main-link-item" title="GitHub" href="https://github.com/lixuetaoleo"><i class="iconfont icon-github"></i></a></div><div class="responsive-bar" onclick="toggle(this)">≡</div></nav><div id="content"><article id="post"><h1>Redux总结</h1><time class="created-date" datetime="2020-04-13T14:54:26.000Z">2020-04-13</time><p>虽然一直在项目中用Redux，但是一直没有对Redux做一个总结，特此借此文作为自己对于理解Redux的一篇总结。</p>
<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>Redux是由Facebook的Flux演变而来，并受到了函数式编程语言Elm的启发。Not only for React，任何JavaScript库都可以应用Redux。</p>
<p>Redux的作者：Dan Abramov &amp; </p>
<p>Redux解决的痛点：<strong>状态管理</strong>与<strong>数据的流动与共享</strong>。</p>
<blockquote>
<p>你可能并不需要Redux： <a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" target="_blank" rel="noopener">“You Might Not Need Redux”</a></p>
</blockquote>
<h2 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h2><p>在React中，数据是单向流动的，只能从父组件到子组件，如果子组件想要给父组件传递数据(props)，那么只能通过父组件传回调给子组件，然后子组件再利用回调来给父组件传数据。假设在大项目中，有非常多的组件，如下图所示，如果绿色的组件(节点)想和红色组件(节点)进行数据传递的话，将原地爆炸。</p>
<p><img src="https://i.loli.net/2020/04/13/1l6jGJgtMTy7AhC.png" alt="image.png"></p>
<p>这个时候，如果利用Redux对state进行统一管理，将很好地解决这个问题</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。 惟一改变 state 的办法是触发 action，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 reducers。</p>
<p>说人话：</p>
<p>把你去图书馆借书这一过程类比为components获取state的过程：你(components)，首先要去图书馆说”我要借书”(action creators)，并把这句话告诉图书馆管理员(dispatch(action))，管理员(store)收到你的请求后会带着这次action去查询记录本(reducer)，通过记录本查询到你要借的书之后把书拿回来然后交给你(返回state)，这样你就成功借到书了(components拿到state)</p>
<p><img src="https://i.loli.net/2020/04/13/zwQKrJB8Nuah6nO.png" alt="image.png"></p>
<p>下面对store, action, dispatch, reducer逐个拆解</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>store就是数据保存的地方，<strong>是redux的核心，所有的数据都要经过store，整个应用有且仅有一个 Store</strong></p>
<p>e.g: 创建store</p>
<pre><code class="js">//store/index.js
import { createStore } from &#39;redux&#39;;
const store = createStore(fn); //传入的fn为reducer</code></pre>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Store对象包含所有数据。如果想得到某个时刻的数据，就要对 Store 生成快照</p>
<p>该时刻数据的集合，就叫做 State</p>
<pre><code class="js">const state = store.getState(); //内置API</code></pre>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>在前面提到，要想改变state，只能通过<code>dispatch(action)</code>这样的格式来进行，在这里先说action</p>
<p>action 是一个对象。必须包括一个type属性，表示 action 的名称。其他属性可以自由设置(即state中想改变的的属性)</p>
<pre><code class="js">const action = {
  type: &#39;ADD_TODO&#39;,
  payload: &#39;Learn Redux&#39;
};</code></pre>
<h3 id="actionCreators-amp-actionTypes"><a href="#actionCreators-amp-actionTypes" class="headerlink" title="actionCreators &amp; actionTypes"></a>actionCreators &amp; actionTypes</h3><p>由于在redux中，state的变化必须交由action，所以action如果都手写，会很麻烦，在日常开发中，可以创建一个actionCreator和actionType来解耦</p>
<pre><code class="js">//store/xx/actionTypes.js
export const ADD_TODO = &#39;/[reducer_name]/add_todo]&#39;;
//.. else types

//store/xx/actionCreators.js
import * as actionTypes from &#39;./actionTypes&#39;;

export const addTodo = (text) =&gt; {
  return {
    type: actionTypes.ADD_TODO,
    text
  }}

//else file
const action = addTodo(&#39;Learn Redux&#39;);</code></pre>
<h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p>action经由dispatch发送至reducer</p>
<pre><code class="js">store.dispatch(addTodo(&#39;Learn Redux&#39;));</code></pre>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p><strong>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</strong></p>
<pre><code class="js">//store/reducer.js
import * as actionTypes from &#39;/xx/actionTypes&#39;;
const defaultState = {
    //可以设置初始状态的state
    items:[]
};

export default (state = defaultState, action) =&gt; {
    switch(action.type){
        case actionTypes.ADD_TODO:
            return Object.assign({},state,{  //注意,不能直接改变state, 必须返回一个全新的对象
                items: items.push(action.text)
            });//这样写也是ok的：return { ...state, ...newState };
        case xxx
        default:
            return state;
    }
};</code></pre>
<p>Reducer 函数最重要的特征：<strong>纯函数</strong>。也就是说，<strong>只要是同样的输入，必定得到同样的输出</strong>，且需要遵守以下约束：</p>
<ul>
<li>不得改写参数</li>
<li>不能调用系统 I/O 的API</li>
<li>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</li>
</ul>
<p>要让store知道reducer的改变，可以利用store的subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数</p>
<pre><code class="js">store.subscribe(()=&gt;{
  let newState = store.getState();
  component.setState(newState);   
});

 //取消subscribe的方法
let unsubscribe = store.subscribe(()=&gt;{
  let newState = store.getState();
  component.setState(newState);   
});

unsubscribe();</code></pre>
<p>在一个较大的应用中，reducer可能有多个，可以把reducer进行拆分，然后进行combine再递给store</p>
<pre><code class="js">import {combineReducers} from &#39;redux&#39;;
import postReducer from &#39;./posts/reducer&#39;;
import userReducer from &#39;./users/reducer&#39;;

export default combineReducers({
    post: postReducer, 
    user: userReducer
});</code></pre>
<h2 id="进阶-React-Redux与redux的中间件"><a href="#进阶-React-Redux与redux的中间件" class="headerlink" title="进阶(React-Redux与redux的中间件)"></a>进阶(React-Redux与redux的中间件)</h2><h3 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h3><p>通过上面的redux基本用法可以看出，如果任意组件想使用store的话，就得引入store然后进行getstate，subscribe等操作，这样用起来很麻烦，可以使用官方封装的react-redux库来简化这些步骤。</p>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>Provider组件可以使得组件拿到state</p>
<pre><code class="js">import React from &#39;react&#39; 
import ReactDOM from &#39;react-dom&#39; 

import { Provider } from &#39;react-redux&#39; 
import store from &#39;./store&#39;
import App from &#39;./App&#39; 
const rootElement = document.getElementById(&#39;root&#39;) 
ReactDOM.render( 
    &lt;Provider store={store}&gt; 
        &lt;App /&gt; 
    &lt;/Provider&gt;, 
    rootElement 
)</code></pre>
<p>connect()函数连接store与component</p>
<pre><code class="js">export default connect(mapStateToProps, mapDispatchToProps)(Component);</code></pre>
<p>其中，mapStateToProps是一个函数。作用是建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。它返回一个对象，里面的每一个键值对就是一个映射。</p>
<pre><code class="js">const mapStateToProps = (state /*, ownProps*/) =&gt; { 
    return { 
        counter: state.counter
    } 
}

//之后在components里使用this.props.counter就能获取值了</code></pre>
<p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p>
<pre><code class="js">const mapDispatchToProps = (dispatch) =&gt; ({
    getBasicInfo(){
        dispatch(actionCreators.getBasicInfo());
    },
    otherFunc(){
        dispatch({
            type:&#39;XXX&#39;,
            XXX
        });
    }
});

//之后在components里使用this.props.getBasicInfo or props.otherFunc就能调用派发dispatch</code></pre>
<h4 id="with-Hooks"><a href="#with-Hooks" class="headerlink" title="with Hooks"></a>with Hooks</h4><p>如果在functional components中要使用两个map，可以用useSelector和useDispatch两个hooks来实现相应的功能。</p>
<pre><code class="js">//mapStateToProps
import {useSelector, useDispatch} from &#39;react-redux&#39;;

const counter = useSelector(state.counter);

//mapDispatchToProps
const dispatch = useDispatch();

dispatch(actionCreators.getBasicInfo());</code></pre>
<h3 id="使用中间件以及异步处理"><a href="#使用中间件以及异步处理" class="headerlink" title="使用中间件以及异步处理"></a>使用中间件以及异步处理</h3><p>关于以上内容，你可能注意到了，dispatch只能传对象，如果state的某项数据需要先从后台获取再改变怎么办呢？可以使用中间件来使得dispatch有异步处理能力</p>
<p>这里列举的是最常用的redux中间件之一–redux-thunk</p>
<pre><code class="js">import thunk from &#39;redux-thunk&#39;

const store = createStore( reducer, /*initial_state*/, applyMiddleware(thunk));//初始状态可选</code></pre>
<p>加载redux-thunk中间件以后，dispatch就有了异步能力了，原理请参考’源码剖析’部分，这里先放上异步dispatch用法</p>
<pre><code class="js">export const getBasicInfo = () =&gt; {
  return (dispatch) =&gt; {
    axios.get(&#39;/api/userinfo.json&#39;).then((res) =&gt; {
      console.log(res);
      const result = res.data.data;
      const action = {
        type: actionTypes.GET_BASIC_INFO,
        name: result.name,
        quote: result.quote
      };
      dispatch(action);
    });
  };
};</code></pre>
<p>可以看到actionCreator返回的是一个函数而不是之前的对象了，这个函数接收一个dispatch参数，然后在做完异步处理后最后进行dispatch的派发交给reducer</p>
<h2 id="useReducer与Context"><a href="#useReducer与Context" class="headerlink" title="useReducer与Context"></a>useReducer与Context</h2><h2 id="React-Redux源码剖析"><a href="#React-Redux源码剖析" class="headerlink" title="React Redux源码剖析"></a>React Redux源码剖析</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">Getting Started with Redux</a><br><a href="https://react-redux.js.org/introduction" target="_blank" rel="noopener">React Redux</a><br><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">Redux 入门教程–阮一峰</a></p>
<hr>
<p>(全文未完待续…)</p>
</article><div id="paginator"></div></div><footer id="bottom"><span>© </span><span>Li Xuetao</span><span>. Powered By </span><a href="http://hexo.io"><span>HEXO</span></a><span>. Theme </span><a href="https://github.com/lixuetaoleo/hexo-theme-leo">leo</a></footer></div><script src="/js/style.js"></script><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script></body></html>