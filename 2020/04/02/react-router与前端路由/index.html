<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta charset="UTF-8"><title>react-router与前端路由 | LI XUETAO</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Lato|Source+Sans+Pro&display=swap" rel="stylesheet"></head><body><div id="layout-page"><nav id="layout-menu"><div class="other-page hide"><a href="/about">About</a><a href="/archives">Archives</a></div><div class="responsive-pad"></div><div id="mega-head"><a href="/">LI XUETAO</a></div><div class="layout-socialmedia hide"><a class="link-item main-link-item" title="Instagram" href="https://www.instagram.com/lixuetaoleo/"><i class="iconfont icon-instagram"></i></a><a class="link-item main-link-item" title="Twitter" href="https://twitter.com/lixuetaoleo"><i class="iconfont icon-twitter"></i></a><a class="link-item main-link-item" title="Weibo" href="https://weibo.com/u/1791741344"><i class="iconfont icon-weibo"></i></a><a class="link-item main-link-item" title="GitHub" href="https://github.com/lixuetaoleo"><i class="iconfont icon-github"></i></a></div><div class="responsive-bar" onclick="toggle(this)">≡</div></nav><div id="content"><article id="post"><h1>react-router与前端路由</h1><time class="created-date" datetime="2020-04-02T03:14:02.000Z">2020-04-02</time><p>一直在用react-router，但之前只是简单地知道这些前端路由库都是借助HTML5里的history API实现，最近决定深入探索一下</p>
<hr>
<h2 id="history-API"><a href="#history-API" class="headerlink" title="history API"></a>history API</h2><p>HTML5 中的history API赋予了JavaScript访问浏览器历史记录的能力，可以在不刷新页面的前提下动态改变浏览器地址栏中的URL地址，动态修改页面上所显示资源，这对于单页应用非常有用。</p>
<h3 id="历史记录栈-History-Stack"><a href="#历史记录栈-History-Stack" class="headerlink" title="历史记录栈(History Stack)"></a>历史记录栈(History Stack)</h3><p>浏览器历史记录由一个URL栈组成，如果用户点击“后退”按钮，指针将指向当前URL的前一个元素，点击“前进”按钮，指针将指回这个URL，如果先点击“后退”再点击一个新的链接，那么栈顶元素将会被这个新的URL覆写。</p>
<h3 id="history-API的安全限制"><a href="#history-API的安全限制" class="headerlink" title="history API的安全限制"></a>history API的安全限制</h3><ol>
<li>只允许访问与该网站同源的历史记录，不允许访问其它的历史记录</li>
<li>只允许将同源的历史记录入栈</li>
</ol>
<h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>可以通过window.history访问history对象</p>
<p>history对象的几个方法：</p>
<ul>
<li>back()</li>
<li>forward()</li>
<li>go(index)</li>
<li>pushState(stateObject, title, url)</li>
<li>replaceState(stateObject, title, url)</li>
</ul>
<p>back方法相当于浏览器上的“后退”按钮。</p>
<p>forward方法相当于浏览器上的“前进”按钮，这个方法只有在调用过back方法或者点击过“后退”按钮时才有用。</p>
<p>go方法可以跳转指定索引的页数，即go(-1) === back(), go(1) === forward()</p>
<p>pushState(stateObject, title, url)中，url是入history栈的URL，title没什么用，stateObject是一个对象，可以包含任何数据，将新的URL推入历史记录堆栈时，该对象会与触发的事件一起传递</p>
<p>replaceState(stateObject, title, url)的用法和pushState差不多，它将history栈中的当前元素(不一定是栈顶元素)替换为新的URL</p>
<p>e.g.</p>
<pre><code class="js">假设现history stack的状态如下所示：
-&gt; google.com/search?kw=history
   google.com
   github.com
let state={};
let title=&#39;&#39;;
let url=&#39;www.apple.com&#39;;
window.history.pushState(state, title, url);</code></pre>
<p>然后发现浏览器地址栏的URL变成了<code>google.com/search?kw=history/www.apple.com</code><br>replaceState效果一样</p>
<p>但是浏览器不会加载这个URL，内容不变</p>
<h3 id="历史记录变更事件-history-change-events"><a href="#历史记录变更事件-history-change-events" class="headerlink" title="历史记录变更事件(history change events)"></a>历史记录变更事件(history change events)</h3><p>history API的<code>onpopstate</code>事件使得网页能监听浏览器历史记录的变化，但由于安全限制，跨域的URL历史记录变化监听不了。</p>
<p>该事件只能由back、forward、go(包括点击浏览器的后退前进按钮)触发，pushState和replaceState不会触发这个事件</p>
<p>可以利用这个事件从URL中提取参数并将相应的内容加载到页面中(AJAX)</p>
<h2 id="react-router-dom实现原理"><a href="#react-router-dom实现原理" class="headerlink" title="react-router-dom实现原理"></a>react-router-dom实现原理</h2><p>有了上述对history API的介绍，下面将简述react-router-dom是怎样借助这个API进行前端路由的。</p>
<p>react-router的思想其实很简单–将URL与UI渲染进行对应</p>
<h3 id="Link组件"><a href="#Link组件" class="headerlink" title="Link组件"></a>Link组件</h3><p>react-router-dom常用的Link组件，本质上返回的是a标签。只是阻止了a标签默认的跳转href的行为。避免直接跳转页面。然后使用history的push(pushState)和replace(replaceState)方法进行跳转。path = to + query + hash</p>
<p>在得到了新的location对象后，系统内部的matchRoutes方法会匹配出Route组件树中与当前location对象匹配的一个子集，并且得到了 nextState，具体的匹配算法不介绍</p>
<p>Router组件的componentWillMount生命周期方法中调用了history.listen(listener)方法。listener会在上述matchRoute 方法执行成功后执行listener(nextState)，接下来执行this.setState(nextState)就可以实现重新渲染 Router组件。</p>
<p>流程图如下所示：</p>
<p><img src="https://i.loli.net/2020/04/05/LGm1WafV9PoUAEp.png" alt="image.png"></p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://tutorials.jenkov.com/html5/history-api.html" target="_blank" rel="noopener">HTML5 History API</a><br><a href="https://zhuzhengyuan.xyz/2019/01/03/understanding-react-router/" target="_blank" rel="noopener">浅谈 react-router 实现原理</a></p>
</article><div id="paginator"></div></div><footer id="bottom"><span>© </span><span>Li Xuetao</span><span>. Powered By </span><a href="http://hexo.io"><span>HEXO</span></a><span>. Theme </span><a href="https://github.com/lixuetaoleo/hexo-theme-leo">leo</a></footer></div><script src="/js/style.js"></script><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script></body></html>