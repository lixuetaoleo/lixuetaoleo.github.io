<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>Effective C++ 9 | Li Xuetao&#39;s Homepage</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Home</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/categories/Software-Development">Software Development</a>
                
                    <a class="menu-item" href="/categories/Inspiration">Inspiration</a>
                
                    <a class="menu-item" href="/categories/Tech">Tech</a>
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Home</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/categories/Software-Development">Software Development</a>
                
                    <a class="menu-item" href="/categories/Inspiration">Inspiration</a>
                
                    <a class="menu-item" href="/categories/Tech">Tech</a>
                
                    <a class="menu-item" href="/archives">Archives</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Effective C++ 9</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Li Xuetao</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">December 9, 2019&nbsp;&nbsp;19:10:37</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Software-Development/">Software Development</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Item-32：确定你的public继承塑模出is-a关系"><a href="#Item-32：确定你的public继承塑模出is-a关系" class="headerlink" title="Item 32：确定你的public继承塑模出is-a关系"></a>Item 32：确定你的public继承塑模出is-a关系</h1><ol>
<li>public继承是”is-a”关系，牢记这条规则</li>
<li>适用于base class上的每一件事情也一定适用于derived class，因为每一个derived class对象也都是一个base class对象。</li>
</ol>
<h1 id="Item-33：避免遮掩继承而来的名称"><a href="#Item-33：避免遮掩继承而来的名称" class="headerlink" title="Item 33：避免遮掩继承而来的名称"></a>Item 33：避免遮掩继承而来的名称</h1><p>假设有如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">private:</span><br><span class="line">	int x;</span><br><span class="line">public:</span><br><span class="line">	virtual void mf1() = 0;</span><br><span class="line">	virtual void mf1(int);</span><br><span class="line">	virtual void mf2();</span><br><span class="line">	void mf3();</span><br><span class="line">	void mf3(double);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived: public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void mf1();</span><br><span class="line">	void mf3();</span><br><span class="line">	void mf4();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line">...</span><br><span class="line">d.mf1(); // 没问题,调用Derived::mf1</span><br><span class="line">d.mf1(x); // 错误,因为Derived::mf1遮掩了Base::mf1</span><br><span class="line">d.mf2(); // 没问题,调用Derived::mf2</span><br><span class="line">d.mf3(); // 没问题,调用Derived::mf3</span><br><span class="line">d.mf3(x); // 错误,因为Derived::mf3遮掩了Base::mf3</span><br></pre></td></tr></table></figure>

<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在Derived Class中：</span><br><span class="line">class Derived: public Base&#123;</span><br><span class="line">public:</span><br><span class="line">	using Base::mf1;  // 让Base Class内名为mf1和mf3的所有东西</span><br><span class="line">	using Base::mf3; // 在Derived作用域内都可见(并且public)</span><br><span class="line">	virtual void mf1();</span><br><span class="line">	void mf3();</span><br><span class="line">	void mf4();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总结: 如果你继承base class并加上重载函数，而又希望重新定义或覆写其中一部分，那么必须为那些原本会被遮掩的每个名称引入一个using声明式，否则将产生遮掩</p>
<p>有时你不想继承base class的所有函数，是可以理解的，但是，在public继承下，绝对不可能发生！！！</p>
<p>在private继承下，继承部分函数的做法：加个转交函数(forwarding function)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void mf1() = 0;</span><br><span class="line">	virtual void mf1(int);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived: private Base&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void mf1() //转交函数暗自成为inline函数</span><br><span class="line">	&#123;Base::mf1();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line">d.mf1(); // 调用的是Derived::mf1</span><br><span class="line">d.mf1(x); // Base::mf1被遮掩</span><br></pre></td></tr></table></figure>

<h1 id="Item-34：区分接口继承和实现继承"><a href="#Item-34：区分接口继承和实现继承" class="headerlink" title="Item 34：区分接口继承和实现继承"></a>Item 34：区分接口继承和实现继承</h1><ol>
<li><p>声明一个纯虚函数的目的是为了让派生类只继承函数接口</p>
</li>
<li><p>非纯虚函数目的是让派生类继承该函数的接口和缺省实现</p>
</li>
<li><p>如果有矛盾：支持接口和缺省应该分开，但是反对用不同的函数分别提供接口和缺省实现(因为会有class命名空间污染问题)，做法是利用“纯虚函数必须在派生类中重新声明，但是它们也能拥有自己的实现”这一特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class AirPlane&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void fly(...) = 0; //pure virtual</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void AirPlane::fly(...)&#123;</span><br><span class="line">	//缺省行为</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ModelA: public Airplane&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void fly(...)&#123;</span><br><span class="line">		AirPlane::fly(...); //调用缺省行为,必须显式调用</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ModeB: public Airplane&#123;</span><br><span class="line">	virtual void fly(...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ModelB::fly(...)&#123;</span><br><span class="line">	//实现自己的版本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明非虚函数的目的是为了令派生类继承函数的接口及一份强制性实现。</p>
</li>
<li><p>由于非虚函数代表的意义是不变性(invariant)和凌驾特异性(specialization)，所以它绝不该在派生类中被重新定义！！！(详见ITEM 36)</p>
</li>
<li><p>总结：</p>
<ul>
<li>纯虚函数只具体指定接口继承</li>
<li>非纯虚函数具体指定接口继承以及缺省实现继承</li>
<li>非虚函数具体指定接口继承以及强制性实现继承</li>
</ul>
</li>
</ol>
<h1 id="Item-36：绝不重新定义继承而来的non-virtual函数"><a href="#Item-36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="Item 36：绝不重新定义继承而来的non-virtual函数"></a>Item 36：绝不重新定义继承而来的non-virtual函数</h1><p>假设以下例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">public:</span><br><span class="line">	void mf();</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D&#123;</span><br><span class="line">public:</span><br><span class="line">	void mf(); //遮掩了B::mf,见item 33</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D x;</span><br><span class="line">B* pB = &amp;x;</span><br><span class="line">D* pD = &amp;x;</span><br><span class="line">pB-&gt;mf(); //调用B::mf()</span><br><span class="line">pD-&gt;mf(); //调用D::mf()</span><br></pre></td></tr></table></figure>

<p>结果理应是pB和pD都通过对象x调用mf，但事与愿违</p>
<p>原因：non-virtual函数是静态绑定，意思是由于pB被声明为一个pointer-to-B，通过pB调用的non-virtual函数永远是B所定义的版本，即使pB指向的是一个派生类的对象。</p>
<p>但是virtual函数是动态绑定，如果mf是个virtual函数，无论通过pB或pD调用mf，都会导致调用D::mf,因为pB和pD真正指的都是一个类型为D的对象。</p>
<h1 id="Item-37：绝不重新定义继承而来的缺省参数值"><a href="#Item-37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="Item 37：绝不重新定义继承而来的缺省参数值"></a>Item 37：绝不重新定义继承而来的缺省参数值</h1><ol>
<li><p>virtual 函数是动态绑定，但是缺省参数值却是静态绑定。</p>
</li>
<li><p>有如下代码:</p>
<pre><code>class Shape{
public:
    enum ShapeColor{Red, Green, Blue};
    virtual void draw(ShapeColor color = Red) const = 0;
    ...
};

class Rectangle: public Shape{
public:
    virtual void draw(ShapeColor color = Green) const;//this is disgusting
};

class Circle: public Shape{
public:
    virtual void draw(ShapeColor color) const;
    注意：这么写则当客户以对象调用该函数时，一定要指定参数值。因为静态绑定下这个函数并不从base继承缺省参数值。
    但是若以指针(或者引用)调用此函数，则可以不指定参数值，因为动态绑定下这个函数从base继承缺省参数值。
};

Shape* ps;
Shape* pc = new Circle;
Shape* pr = new Rectangle;</code></pre><p> 这三个指针的静态类型都是Shape*，动态类型是它们所指的对象的类型。</p>
<p> Virtual函数由动态绑定而来，即调用一个virtual函数时，究竟调用哪一份代码，取决于发出调用的那个对象的动态类型。</p>
<p> 但是，缺省参数值是静态绑定</p>
<pre><code>pr-&gt;draw();  // 调用Rectangle::draw(Shape::Red)!</code></pre><p> 在此例中，pr动态类型是Rectangle<em>，调用rectangle的virtual函数，没问题；问题在于Rectangle::draw的缺省参数是GREEN，但是由于pr的静态类型是Shape</em>，所以在此处调用的缺省参数值来自shape而非rectangle。</p>
<p> 以上问题不仅局限于指针，引用也是如此。</p>
</li>
<li><p>C++采用这种方式运作的原因：运行期效率。为了程序的执行速度和编译器实现上的简易度，C++做出了这样的取舍。</p>
</li>
<li><p>如果提供给derived class与base class相同的缺省值，出现的问题是代码重复，因为如果base class缺省参数值变了，所有那些重复给值的class也必须改变。</p>
</li>
<li><p>解决上面问题的trick：</p>
<pre><code>class Shape{
public:
    enum ShapeColor{Red, Green, Blue};
    void draw(ShapeColor color = red) const{
        doDraw(color);
    }
    ...
private:
    virtual void doDraw(ShapeColor color) const = 0;
    //真正的工作在这里完成
};

class Rectangle: public Shape{
public:
...
private:
    virtual void doDraw(ShapeColor color) const;
    //无需指定缺省参数值.
};</code></pre><p> 由于non-virtual函数不应该把派生类覆写，因此这个设计使得draw函数的color缺省参数总为Red.</p>
</li>
</ol>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/C/"># C++</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/12/12/CSS居中的方式/">CSS居中的方式</a>
            
            
            <a class="next" rel="next" href="/2019/12/09/从SSH应用中学到的东西/">从SSH应用中学到的东西</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Li Xuetao | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
