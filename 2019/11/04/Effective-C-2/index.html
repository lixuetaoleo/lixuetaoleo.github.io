<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta charset="UTF-8"><title>Effective-C++-2 | Li Xuetao</title><link rel="stylesheet" href="/css/temp.css"><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Lato|Source+Sans+Pro&display=swap" rel="stylesheet"></head><body><div id="layout-page"><nav id="layout-menu"><div class="other-page"><a href="/about">About</a><a href="/archives">Archives</a></div><a id="mega-head" href="/">LI XUETAO</a><div class="layout-socialmedia"><a class="link-item main-link-item" title="Instagram" href="https://www.instagram.com/lixuetaoleo/"><i class="iconfont icon-instagram"></i></a><a class="link-item main-link-item" title="Twitter" href="https://twitter.com/lixuetaoleo"><i class="iconfont icon-twitter"></i></a><a class="link-item main-link-item" title="Weibo" href="https://weibo.com/u/1791741344"><i class="iconfont icon-weibo"></i></a><a class="link-item main-link-item" title="GitHub" href="https://github.com/lixuetaoleo"><i class="iconfont icon-github"></i></a></div></nav><div id="content"><article id="post"><h1>Effective-C++-2</h1><time class="created-date" datetime="2019-11-04T14:24:34.000Z">2019-11-04</time><h1 id="Item-4：确认对象被使用前已经先被初始化"><a href="#Item-4：确认对象被使用前已经先被初始化" class="headerlink" title="Item 4：确认对象被使用前已经先被初始化"></a>Item 4：确认对象被使用前已经先被初始化</h1><ol>
<li>内置类型以外的任何其他东西，初始化的责任落在ctor上。规则很简单：确保每一个ctor都将对象里面的每一个成员初始化。</li>
<li>注意：别混淆了赋值和初始化。C++规定，对象的成员变量其初始化动作发生在进入ctor本体之前，所以写构造函数时，应该用member initialization list来替换赋值动作。如果采用ctor函数体赋值，首先会调用default ctor然后再对成员变量进行赋值，这样一来default ctor的一切作为都浪费了，使得效率也比较低。</li>
<li>在initialization list中列出所有的成员变量，这样就不用记住哪些成员变量无需初值。</li>
<li>成员变量是const或者reference，它们就一定要初值，不能被赋值。</li>
<li>有时候一个class有多个ctor，这时如果用member initialization list进行初始化，则会显得繁琐，此时则可以利用一个赋值函数(通常是private)，把那些“赋值表现得像初始化一样好”的变量(通常是内置类型)，放到这个函数中然后在构造函数中进行调用。<code>但是还是更推荐member initialization list</code>。</li>
<li>member initialization list列出的成员变量，其排列顺序应该和它们在class中声明次序相同。</li>
</ol>
<h1 id="Item-5：了解C-默默编写并调用哪些函数"><a href="#Item-5：了解C-默默编写并调用哪些函数" class="headerlink" title="Item 5：了解C++默默编写并调用哪些函数"></a>Item 5：了解C++默默编写并调用哪些函数</h1><ol>
<li>写一个类，就算没写ctor，dctor，拷贝构造，拷贝赋值，编译器也会声明这几个default函数，并且它们是public和inline。</li>
<li>除非这个类的基类有声明virtual的析构函数，否则编译器产出的析构函数是非虚的。</li>
<li>如果打算在一个内含reference成员或const成员的class支持赋值操作，那么必须定义自己的拷贝赋值操作符，否则编译不通过。</li>
<li>如果某个基类讲拷贝赋值操作符声明为private，编译器不会为派生类生成一个拷贝赋值操作符。因为派生类无权访问基类的private。</li>
</ol>
<h1 id="Item-6：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#Item-6：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="Item 6：若不想使用编译器自动生成的函数，就该明确拒绝"></a>Item 6：若不想使用编译器自动生成的函数，就该明确拒绝</h1><ol>
<li><p>可以将这些方法放在private里，这样就成功阻止它们被调用。</p>
</li>
<li><p>但是上面的做法不是100%安全，因为member函数和friend函数还是可以调用。因此可以将这些函数进行声明但是不定义，此时如果某些函数想调用它们，则会报链接错误。</p>
</li>
<li><p>如果想把链接错误转为编译错误，可以利用如下方法：</p>
<p>设计一个把拷贝构造和拷贝赋值放进private里的基类(命名为Uncopyable)，然后派生类继承这个基类。</p>
<p>tip: boost提供了一个noncopyable的class。</p>
<p>这样一来，如果某个member函数或者friend函数想调用拷贝赋值或者拷贝构造，编译器报错。原因见Item5的第四条。</p>
</li>
</ol>
</article><div id="paginator"></div></div><footer id="bottom"><span>Created By </span><a href="https://lixuetaoleo.github.io">Li Xuetao</a><span> | </span><a href="http://hexo.io"><span>HEXO</span></a></footer></div><script src="/js/temp.js"></script><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script></body></html>