<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta charset="UTF-8"><title>Effective C++ 6 | Li Xuetao</title><link rel="stylesheet" href="/css/temp.css"><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
<link href="https://fonts.googleapis.com/css?family=Amatic+SC|Lato|Source+Sans+Pro&display=swap" rel="stylesheet"></head><body><div id="layout-page"><nav id="layout-menu"><div class="other-page hide"><a href="/about">About</a><a href="/archives">Archives</a></div><div class="responsive-pad"></div><div id="mega-head"><a href="/">LI XUETAO</a></div><div class="layout-socialmedia hide"><a class="link-item main-link-item" title="Instagram" href="https://www.instagram.com/lixuetaoleo/"><i class="iconfont icon-instagram"></i></a><a class="link-item main-link-item" title="Twitter" href="https://twitter.com/lixuetaoleo"><i class="iconfont icon-twitter"></i></a><a class="link-item main-link-item" title="Weibo" href="https://weibo.com/u/1791741344"><i class="iconfont icon-weibo"></i></a><a class="link-item main-link-item" title="GitHub" href="https://github.com/lixuetaoleo"><i class="iconfont icon-github"></i></a></div><div class="responsive-bar" onclick="toggle(this)">≡</div></nav><div id="content"><article id="post"><h1>Effective C++ 6</h1><time class="created-date" datetime="2019-11-09T11:28:31.000Z">2019-11-09</time><h2 id="Item-18：让接口容易被正确使用，不易被误用"><a href="#Item-18：让接口容易被正确使用，不易被误用" class="headerlink" title="Item 18：让接口容易被正确使用，不易被误用"></a>Item 18：让接口容易被正确使用，不易被误用</h2><ol>
<li>要保证这条原则，首要考虑客户可能做出什么样的错误。</li>
<li>除非有更好的理由，否则应该尽量让自己写的type的行为与内置types一致。比如说a, b都是ints，那么对a*b不合法，所以自己写的type也应该如此。总之，如果遇到什么疑问，可以拿int来做范本。</li>
<li>为了防止客户使用智能指针，可以先发制人，令要返回指针的函数就返回一个智能指针。</li>
<li>同样的，为了防止客户利用delete来析构智能指针，可以在构造智能指针的时候传入一个删除器。</li>
</ol>
<h2 id="Item-19：设计class犹如设计type"><a href="#Item-19：设计class犹如设计type" class="headerlink" title="Item 19：设计class犹如设计type"></a>Item 19：设计class犹如设计type</h2><ol>
<li><p>在设计一个class时，要按照设计type去考虑：</p>
<ul>
<li>新type对象如何被创建和销毁</li>
<li>对象的初始化和对象的赋值该有什么样的差别</li>
<li>新type的对象如果被passed by value，意味着什么</li>
<li>什么是新type的“合法值”</li>
<li>新type需要配合某个继承图系吗</li>
<li>新type需要什么样的转换</li>
<li>什么样的操作符和函数对此新type而言是合理的</li>
<li>什么样的标准函数应驳回</li>
<li>谁该用新type的成员</li>
<li>什么是新type的“未声明接口”</li>
<li>新type有多么一般化</li>
<li>真的需要一个新type吗？因为如果只是定义新的派生类以便为既有的类添加机能，说不定单纯定义一个或多个非成员函数或者模板，更能达到目标。</li>
</ul>
</li>
</ol>
<h2 id="Item-20：以pass-by-reference-to-const替换pass-by-value"><a href="#Item-20：以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="Item 20：以pass by reference to const替换pass by value"></a>Item 20：以pass by reference to const替换pass by value</h2><ol>
<li><p>pass by value的两个问题：</p>
<ul>
<li><p>构造和析构的代价太大</p>
<p>对于如下两个类：</p>
<pre><code>class Person{
public:
    Person();
    virtual ~Person();
    ...
private:
    std::string name;
    std::tring address;
};

class Student : public Person{
public:
    Student();
    ~Student();
    ...
private:
    std::string schoolName;
    std::string schoolAddress;
};

bool validateStudent(Student s); //以pass by value方式接受参数
Student Plato;
bool isValidate = validateStudent(Plato);//调用函数</code></pre><p>对于该例子，以pass by value方式传递一个Student对象会导致调用一次Student构造函数，一次Person构造函数，四次string的构造函数。当函数内的那个Student副本被销毁，又要调用每一个构造对应的析构，所以这次调用整体成本是“6次构造6次析构”</p>
</li>
<li><p>对象切割问题</p>
<pre><code>class Window{
public:
    ...
    std::string name() const;
    virtual void display() const;    
};
class WindowWithScrollBars : Window{
public:
    ...
    virtual void display() const;    
};  

void printNameAndDisplay(Window w){
  std::cout&lt;&lt;w.name()&lt;&lt;std::endl;
  w.display();
}

WindowWithScrollBars wwsb;
printNameAndDisplay(wwsb);</code></pre><p>以上操作会导致传入print…函数的w对象被构造为Window对象，无论传过来的对象原本是什么类型，所以进而调用window类里的display()。</p>
<p>但是以by reference to const传递，就能解决这个问题，传过去什么对象就是什么对象。</p>
</li>
</ul>
</li>
<li><p>在C++底层，reference就是指针，因此pass by reference通常意味着真正传递的是指针，所以对于内置类型(以及STL迭代器和函数对象)，pass by value比reference效率要高一些。</p>
</li>
</ol>
<h2 id="Item-21：必须返回对象时，别妄想返回其reference"><a href="#Item-21：必须返回对象时，别妄想返回其reference" class="headerlink" title="Item 21：必须返回对象时，别妄想返回其reference"></a>Item 21：必须返回对象时，别妄想返回其reference</h2><ol>
<li>对于如下代码：<pre><code> const Rational&amp; operator* (const Rational&amp; lhs, const Rational&amp; rhs){
   Rational result(lhs.n * rhs.n, lhs.d * rhs.d)
   return result;
 }</code></pre> 当函数返回一个reference(或者指针)指向result，但result是个local对象，而local对象在函数退出前就被销毁了！</li>
<li>一个“必须返回新对象”的正确写法：让函数返回一个新对象<pre><code> inline const Rational operator* (const Rational&amp; lhs, const Rational&amp; rhs){      
   return Rational(lhs.n * rhs.n, lhs.d * rhs.d);
 }</code></pre> 这样做需承担返回值构造和析构的成本，但是对于上面的错，这代价也是微乎其微了。</li>
</ol>
<h2 id="Item-22：将成员变量声明为private"><a href="#Item-22：将成员变量声明为private" class="headerlink" title="Item 22：将成员变量声明为private"></a>Item 22：将成员变量声明为private</h2><p>原因：</p>
<ol>
<li>为了语法一致性。把成员都放入private，客户通过对象访问成员变量的方法就是成员函数了，就不用考虑访问变量还是函数，纠结要不要带括号的问题。</li>
<li>对成员变量的处理有更精确的控制。可以写出禁止访问，只读，读写，甚至“只写”等权限。</li>
<li>封装性。如果通过函数访问成员变量，那么今后可改以某个计算替换这个成员变量，而class的客户也不会知道class内部实现发生了变化。而对于protected，其封装性并不比public成员变量高，理由如下：假设成员变量放在public里，最终取消了它，所有使用它的客户代码都会被破坏，而那是一个不可知的大量。但是对于protected变量，最终取消了它，所有使用它的派生类都会被破坏，也是一个不可知的大量。因此protected封装性依旧缺乏。</li>
</ol>
<p>总结</p>
<p>从封装的角度看，其实只有两种访问权限：private(提供封装)和其他(不提供封装)</p>
</article><div id="paginator"></div></div><footer id="bottom"><span>Created By </span><a href="https://lixuetaoleo.github.io">Li Xuetao</a><span> | </span><a href="http://hexo.io"><span>HEXO</span></a></footer></div><script src="/js/temp.js"></script><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script></body></html>