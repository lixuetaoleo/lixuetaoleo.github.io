{"componentChunkName":"component---src-template-index-tsx","path":"/post/JavaScript中的async-await/","result":{"data":{"markdownRemark":{"html":"<ol>\n<li>它们是ES2017加入的关键字，充当Promise的语法糖。</li>\n<li>async关键字放在函数声明之前，它将任何函数转化为Promise，使得该函数返回后可以用then()方法。</li>\n</ol>\n<pre><code class=\"language-js\">//写法1\nasync function hello() { return \"Hello\" };\n//写法2\nlet hello = async function() { return \"Hello\" };\n//写法3\nlet hello = async () => { return \"Hello\" };\nconsole.log(hello()); // Promise { 'hello' }\nhello().then((result)=>console.log(result)); // hello\n</code></pre>\n<p>通过仅在函数声明为异步时添加必要的处理，JavaScript引擎可以优化程序。</p>\n<ol start=\"3\">\n<li>await可以放在任何基于异步声明的函数之前，只能在异步函数内部工作暂停代码在该行上，直到promise完成，然后返回结果值。与此同时，可能正在等待执行机会的其他代码也会这样做。可以在调用任何返回Promise的函数时使用await，包括Web API函数。</li>\n</ol>\n<p>有如下基于Promise的代码：</p>\n<pre><code class=\"language-js\">fetch('coffee.jpg')\n.then(response => response.blob())\n.then(myBlob => {\n    let objectURL = URL.createObjectURL(myBlob);\n    let image = document.createElement('img');\n    image.src = objectURL;\n    document.body.appendChild(image);\n})\n.catch(e=>{\n    console.log('there has been a problem with your fetch operation: ' + e.message);\n});\n</code></pre>\n<p>利用async和await进行优化</p>\n<pre><code class=\"language-js\">async function myFetch(){\n    let response = await fetch('coffee.jpg');\n    let myBlob = await response.blob();\n    let objectURL = URL.createObjectURL(myBlob);\n    let image = document.createElement('img');\n    image.src = objectURL;\n    document.body.appendChild(image);\n}\nmyFetch();\n</code></pre>\n<p>或者可以把async/await和Promise进行混合搭配:</p>\n<pre><code class=\"language-js\">async function myFetch() {\n  let response = await fetch('coffee.jpg');\n  return await response.blob();\n}\n\nmyFetch().then((blob) => {\n  let objectURL = URL.createObjectURL(blob);\n  let image = document.createElement('img');\n  image.src = objectURL;\n  document.body.appendChild(image);\n});\n</code></pre>\n<p>async/await也可以try...catch</p>\n<pre><code class=\"language-js\">async function myFetch() {\n  try {\n    let response = await fetch('coffee.jpg');\n    let myBlob = await response.blob();\n\n    let objectURL = URL.createObjectURL(myBlob);\n    let image = document.createElement('img');\n    image.src = objectURL;\n    document.body.appendChild(image);\n  } catch(e) {\n    console.log(e);\n  }}\nmyFetch();\n</code></pre>\n<hr>\n<h3>async/await的一个缺点</h3>\n<p>await关键字阻止执行所有代码，直到promise完成，就像执行同步操作一样。它允许其他任务在此期间继续运行，但自己的代码被阻止。</p>\n<p>这意味着代码可能会因为大量等待的promises相继发生而变慢。<code>每个await将等待前一个完成</code>，而实际上我们想要的是promises同时开始处理（就像我们没有使用async/await时那样）。</p>\n<p>有一种模式可以缓解这个问题 ––通过关闭所有promise进程将Promise对象存储在变量中，然后等待触发它们。</p>\n<p>如下段代码：</p>\n<pre><code class=\"language-js\">function timeoutPromise(interval) {\n        return new Promise((resolve, reject) => {\n          setTimeout(function(){\n            resolve(\"done\");\n          }, interval);\n        });\n      };\n /*主要是这段\nasync function timeTest() {\n        await timeoutPromise(3000);\n        await timeoutPromise(3000);\n        await timeoutPromise(3000);\n}\n*/\n      let startTime = Date.now();\n      timeTest().then(() => {\n        let finishTime = Date.now();\n        let timeTaken = finishTime - startTime;\n        console.log('finish' + Date.now());\n        alert(\"Time taken in milliseconds: \" + timeTaken);\n      })\n      console.log('start'+Date.now());\n</code></pre>\n<p>上面注释那一段会等待所有三个timeoutPromise()调用，使每个调用3秒钟。后续的每一个都被迫等到最后一个完成，导致最后总用时9s。</p>\n<p>对上面那段优化：</p>\n<pre><code class=\"language-js\">async function timeTest() {\n  const timeoutPromise1 = timeoutPromise(3000);\n  const timeoutPromise2 = timeoutPromise(3000);\n  const timeoutPromise3 = timeoutPromise(3000);\n\n  await timeoutPromise1;\n  await timeoutPromise2;\n  await timeoutPromise3;\n}\n</code></pre>\n<p>在这里，将三个Promise对象存储在变量中，这样可以同时启动它们关联的进程。接下来，等待他们的结果 - 因为promise都在基本上同时开始处理，promise将同时完成;</p>\n<p>第二个示例警报框报告总运行时间刚刚过3秒！</p>\n<p><code>对于使用async/await造成的性能问题，必须仔细测试代码，并在性能开始受损时牢记这一点。</code></p>\n<hr>\n<h3>总结--async/await比Promise更好的七个原因</h3>\n<ol>\n<li>语法更加简洁</li>\n<li>可以用传统的try...catch来捕获error(Promise只能调用.catch()方法来捕获error)</li>\n<li>在条件语句时没有那么繁琐(即没有Promise有那么多括号要写)</li>\n</ol>\n<pre><code class=\"language-js\">const makeRequest = () => {\n  return getJSON()\n    .then(data => {\n      if (data.needsAnotherRequest) {\n        return makeAnotherRequest(data)\n          .then(moreData => {\n            console.log(moreData)\n            return moreData\n          })\n      } else {\n        console.log(data)\n        return data\n      }\n    })\n}\n\nconst makeRequest = async () => {\n  const data = await getJSON()\n  if (data.needsAnotherRequest) {\n    const moreData = await makeAnotherRequest(data);\n    console.log(moreData)\n    return moreData\n  } else {\n    console.log(data)\n    return data    \n  }\n}\n</code></pre>\n<ol start=\"4\">\n<li>中间值\n比如有promise1, promise2, promise3,运行promise2需要promise1的返回值，然后运行promise3又需要promise2和promise1的返回值，如果用Promise的写法会出现下面的情况：</li>\n</ol>\n<pre><code class=\"language-js\">const makeRequest = () => {\n  return promise1()\n    .then(value1 => {\n      // do something\n      return promise2(value1)\n        .then(value2 => {\n          // do something          \n          return promise3(value1, value2)\n        })\n    })\n}\n</code></pre>\n<p>而如果用async,则会简单许多</p>\n<pre><code class=\"language-js\">const makeRequest = async () => {\n  const value1 = await promise1()\n  const value2 = await promise2(value1)\n  return promise3(value1, value2)\n}\n</code></pre>\n<ol start=\"5\">\n<li>错误栈(error stack)\n使用Promise的.then()链式调用，在报错时错误信息非常不清晰，只能有诸如<code>Error: oops at callAPromise.then.then.then.then.then (index.js:8:13)</code>这样的信息，而使用async的错误信息如下<code>Error: oops at makeRequest (index.js:7:9)</code></li>\n<li>debug更友好，可以打断点</li>\n<li>await可以作用于同步代码和异步代码</li>\n</ol>\n<p>假设你想利用Date.now()来记录某段代码运行了多久，使用Promise的情况下对于同步代码会报错</p>\n<pre><code class=\"language-js\">const recordTime = (makeRequest) => {\n  const timeStart = Date.now();\n  makeRequest().then(() => { // throws error for sync functions (.then is not a function)\n    const timeEnd = Date.now();\n    console.log('time take:', timeEnd - timeStart);\n  })\n}\n</code></pre>\n<p>而使用async/await则没有问题</p>\n<pre><code class=\"language-js\">const recordTime = async (makeRequest) => {\n  const timeStart = Date.now();\n  await makeRequest(); // works for any sync or async function\n  const timeEnd = Date.now();\n  console.log('time take:', timeEnd - timeStart);\n}\n</code></pre>\n<p>总之，async/await可以使代码更加简洁，优雅！</p>\n<hr>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/Async_await\">MDN-async和await:让异步编程更简单</a></li>\n<li><a href=\"https://dev.to/gafi/7-reasons-to-always-use-async-await-over-plain-promises-tutorial-4ej9\">7 Reasons Why JavaScript Async/Await Is Better Than Plain Promises (Tutorial)</a></li>\n</ul>","frontmatter":{"title":"JavaScript中的async/await","date":"2020-02-13","titleImage":null}}},"pageContext":{"slug":"/JavaScript中的async-await/"}}}