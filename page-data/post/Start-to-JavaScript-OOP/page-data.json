{"componentChunkName":"component---src-template-index-tsx","path":"/post/Start-to-JavaScript-OOP/","result":{"data":{"markdownRemark":{"html":"<ul>\n<li>\n<p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。</p>\n<p>原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象：</p>\n<p>  var robot = {\nname: 'Robot',\nheight: 1.6,\nrun: function () {\nconsole.log(this.name + ' is running...');\n}\n};</p>\n<p>我们看这个robot对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！\n于是我们把它改名为Student，然后创建出xiaoming：</p>\n<pre><code>var Student = {\nname: 'Robot',\nheight: 1.2,\nrun: function () {\n    console.log(this.name + ' is running...');\n}\n};\n\nvar xiaoming = {\n    name: '小明'\n};\n\nxiaoming.__proto__ = Student;\n</code></pre>\n</li>\n<li>JavaScript的原型链和Java的Class区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。</li>\n<li>\n<p>在编写JavaScript代码时，不要直接用obj._<strong>_proto</strong>去改变一个对象的原型，并且，低版本的IE也无法使用<strong>proto__</strong>。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming：</p>\n<pre><code>// 原型对象:\nvar Student = {\n    name: 'Robot',\n    height: 1.2,\n    run: function () {\n        console.log(this.name + ' is running...');\n    }\n};\n\nfunction createStudent(name){\n    // 基于Student原型创建一个新对象:\n   var s = Object.create(Student);\n    // 初始化新对象:\n    s.name = name;\n    return s;\n}\n\nvar xiaoming = createStudent('小明');\nxiaoming.run(); // 小明 is running...\nxiaoming.__proto__ === Student; // true\n</code></pre>\n</li>\n<li>原型继承暂时没有看。。感觉略过于复杂。。。</li>\n<li>关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。继承用extends</li>\n<li>因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以试试Babel这个工具。</li>\n</ul>","frontmatter":{"title":"Start to JavaScript--OOP","date":"2019-09-18","titleImage":null}}},"pageContext":{"slug":"/Start-to-JavaScript-OOP/"}}}