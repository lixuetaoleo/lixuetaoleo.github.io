{"componentChunkName":"component---src-template-index-tsx","path":"/post/Node-js-Express入门/","result":{"data":{"markdownRemark":{"html":"<h2>安装</h2>\n<ol>\n<li>\n<p>安装node和npm：sudo apt install -y nodejs</p>\n<p>安装完成后在终端输入node -v 和 npm -v 如果有输出说明安装成功</p>\n</li>\n<li>\n<p>安装express</p>\n<p>sudo npm install express-generator -g\n-g代表全局安装，一般情况下工具都可以加-g进行全局安装</p>\n</li>\n</ol>\n<h2>运行</h2>\n<ol>\n<li>mkdir 项目名 新建一个项目并cd至这个新建的文件夹里</li>\n<li>express --view=pug  应用pug视图引擎生成一个项目骨架</li>\n<li>npm install 安装所需依赖</li>\n<li>DEBUG=express-locallibrary-tutorial:* npm start\n以DEBUG模式运行这个项目(在命令行会有信息输出)，如果直接npm start则不会有信息输出</li>\n<li>在浏览器键入<code>http://localhost:3000/</code>，可以看到默认的信息</li>\n<li>\n<p>一个trick--项目在进行了文件改动之后自动刷新重启</p>\n<ol>\n<li>利用nodemon，安装：sudo npm install -g nodemon</li>\n<li>\n<p>还可以把它作为开发依赖将安装在本地，于是使用这个项目的开发人员只要安装这个应用就能自动获得：</p>\n<ol>\n<li>npm install --save-dev nodemon</li>\n<li>项目的 package.json 文件将自动添加一个新的属性：  \"devDependencies\": {\"nodemon\": \"^1.18.9\" }</li>\n<li>\"scripts\": {    \"start\": \"node ./bin/www\",    \"devstart\": \"nodemon ./bin/www\"  },</li>\n</ol>\n</li>\n<li>用新建的 devstart 命令启动服务器：DEBUG=express-locallibrary-tutorial:* npm run devstart</li>\n</ol>\n</li>\n</ol>\n<hr>\n<p>Express中间件的使用：</p>\n<ol>\n<li>// 用 use() 为所有的路由和动词添加该函数\napp.use(a<em>middleware</em>function);</li>\n<li>// 用 use() 为一个特定的路由添加该函数\napp.use('/someroute', a<em>middleware</em>function);</li>\n<li>// 为一个特定的 HTTP 动词和路由添加该函数\napp.get('/', a<em>middleware</em>function);</li>\n</ol>\n<pre><code class=\"language-JavaScript\">const express = require('express');\nconst app = express();\n\n// 示例中间件函数\nconst a_middleware_function = (req, res, next) => {\n  // ... 进行一些操作\n  next(); // 调用 next() ，Express 将调用处理链中下一个中间件函数。\n};\n\n// 用 use() 为所有的路由和动词添加该函数\napp.use(a_middleware_function);\n\n// 用 use() 为一个特定的路由添加该函数\napp.use('/someroute', a_middleware_function);\n\n// 为一个特定的 HTTP 动词和路由添加该函数\napp.get('/', a_middleware_function);\n\napp.listen(3000);\n</code></pre>\n<ol>\n<li>MongoDB 数据库里，“集合”中的“文档” 类似于 关系数据库里“表”中的“行”。</li>\n<li>mongodb+srv://lixuetao:13579@cluster0-d9cdx.azure.mongodb.net/\nlocal-library?retryWrites=true&#x26;w=majority</li>\n<li>控制器不是单个中间件函数（带参数（req, res, next）），而是指定一组中间件函数。数组传递给路由器函数，<code>并按顺序调用</code>每个方法。</li>\n<li>trim()，以删除任何尾随/前导空格</li>\n<li>escape()转义任何危险的 HTML 字符。</li>\n<li>所有的 POST控制器中，都使用了相同的模式：我们运行验证器，然后运行消毒器，然后检查错误，并使用错误信息重新呈现表单，或保存数据。</li>\n<li>可以用菊花链式连接验证器，使用withMessage()指定在前一个验证方法失败时，显示的错误消息。这使得在没有大量代码重复的情况下，提供特定的错误消息变得非常容易。</li>\n<li>可以使用optional()函数，仅在输入字段时运行后续验证（这允许我们验证可选字段）。例如，下面我们检查可选的出生日期是否符合 ISO8601 标准（checkFalsy 旗标，表示我们接受空字符串或null作为空值）</li>\n<li>参数从请求中作为字符串接收。我们可以使用toDate()（或toBoolean()等）将这些转换为正确的JavaScript类型。</li>\n</ol>\n<hr>\n<hr>\n<hr>\n<h2>app.js</h2>\n<ol>\n<li>Express应用的入口是app.js。路由模块、数据库连接、模板引擎设置、各种app.use(...)都在这里配置</li>\n<li>\n<p>appjs都是通过app这个变量来操作</p>\n<pre><code class=\"language-js\">const express = require('express');\nconst app = express();\napp.use()...\napp.set()...\n</code></pre>\n<pre><code class=\"language-js\">//连接mongodb\nconst mongoose = require('mongoose');\nconst mongoDB = 'mongodb+srv://lixuetao:13579@cluster0-d9cdx.azure.mongodb.net/local-library?retryWrites=true&#x26;w=majority';\nmongoose.connect(mongoDB, { useNewUrlParser: true });\nconst db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'MongoDB connection error:'));\n</code></pre>\n</li>\n</ol>\n<hr>\n<h2>mongoose用法/Model层</h2>\n<ol>\n<li>在项目里创建models文件夹，所有的mongoDB的schema都放在这里。</li>\n</ol>\n<pre><code class=\"language-js\">const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\nconst your_schema_name = new Schema({\n    property_name:        \n{\n    type:String/Date/Number/Boolean...,\n    required: true/false,\n    min:...,\n    max:...,\n    default:...,\n    enum:[],\n},\n//如果要引用别的schema\nproperty_name:\n{\n    type: Schema.Types.ObjectId, \n    ref: 'Author', \n    required: true\n}\n});\n</code></pre>\n<ol>\n<li>可以用virtual结合几个真实属性(比如属性分为了firstname和lastname，要添加一个fullname属性用virtual就可以)</li>\n</ol>\n<pre><code class=\"language-js\">personSchema.virtual('fullName').\n  get(function() {\n    return this.name.first + ' ' + this.name.last;\n  }).\n  set(function(v) {\n    this.name.first = v.substr(0, v.indexOf(' '));\n    this.name.last = v.substr(v.indexOf(' ') + 1);\n  });\n\naxl.fullName = 'William Rose'; // Now `axl.name.first` is \"William\"\n</code></pre>\n<ol>\n<li>最后导出这个schema</li>\n</ol>\n<pre><code class=\"language-js\">module.exports = mongoose.model('Book/Author/...', your_schema_name);\n</code></pre>\n<ol>\n<li>几个mongoose的API</li>\n</ol>\n<pre><code class=\"language-js\">findByIdAndUpdate\nfindByIdAndRemove\n</code></pre>\n<hr>\n<h2>Controller层</h2>\n<ol>\n<li>controller层主要处理GET,POST等操作。首先要在routes文件夹下写路由的函数，然后传入回调各路由函数。e.g.:</li>\n</ol>\n<pre><code class=\"language-js\">const express = require('express');\nconst router = express.Router();\n\nconst book_controller = require('../controllers/bookController');\n\nrouter.get('/book/create', book_controller.book_create_get);\nrouter.post('/book/create', book_controller.book_create_post);\n//路由URL可以传递参数\n比如：'/book/:id/delete'\n\nmodule.exports = router;\n</code></pre>\n<ol>\n<li>\n<p>controller文件夹里的函数就是各个回调函数。</p>\n<ol>\n<li>查找某一个Schema的内容</li>\n</ol>\n<pre><code class=\"language-js\">exports.author_list = function (req, res, next) {\n    Author.find()\n        .sort([['family_name', 'ascending']])\n     .exec(function (err, list_authors) {\n          if (err) { return next(err); }\n          //Successful, so render\nres.render('author_list', { title: 'Author List', author_list: list_authors });\n    });\n};\n//find()不传参数找到所有的内容\n//sort给排序\n//exec执行回调，最后传参给模板引擎进行render,render函数的第一个参数是要render的文件名，第二个参数是给引擎传的内容。\n</code></pre>\n</li>\n<li>查找多个schema的内容</li>\n</ol>\n<pre><code>```js\nexports.author_detail = function (req, res, next) {\n  async.parallel({\n    author: function (callback) {\n      Author.findById(req.params.id)\n        .exec(callback)\n    },\n    authors_books: function (callback) {          Book.find({ 'author': req.params.id }, 'title summary')\n        .exec(callback)\n    },\n  }, function (err, results) {\n    if (err) { return next(err); } // Error in API usage.\n    if (results.author == null) { // No results.\n      var err = new Error('Author not found');\n      err.status = 404;\n      return next(err);\n    }\n    // Successful, so render.\n    res.render('author_detail', { title: 'Author Detail', author: results.author, author_books: results.authors_books });\n  });\n};\n//req.params.id获取URL传过来的ID\n//async.parallel({prop:func1, prop:func2},回调)\n```\n</code></pre>\n<ol>\n<li>POST的回调可以用一个数组存多个函数，按顺序执行，首先清洗，然后sanitizeBody，validationResult，最后再对req、res和next进行处理</li>\n</ol>\n<pre><code>```js\nexports.author_create_post = [\n  body('first_name').isLength({ min: 1 }).trim().withMessage('first name must be specified')\n    .isAlphanumeric().withMessage('First name has non-alphanumeric characters.'),\n  body('family_name').isLength({ min: 1 }).trim().withMessage('family name must be specified')\n    .isAlphanumeric().withMessage('Family name has non-alphanumeric characters.'),\n  body('date_of_birth', 'invalid date of birth').optional({ checkFalsy: true }).isISO8601(),\n  body('date_of_death', 'invalid date of death').optional({ checkFalsy: true }).isISO8601(),\n  sanitizeBody('first_name').trim().escape(),\n  sanitizeBody('family_name').trim().escape(),\n  sanitizeBody('date_of_birth').toDate(),\n  sanitizeBody('date_of_death').toDate(),\n  (req, res, next) => {\n    const errs = validationResult(req);\n    if (!errs.isEmpty()) {\n      res.render('author_form', { title: 'Create Author', author: req.body, errors: errors.array() });\n      return;\n    }\n    else {\n      const author = new Author({\n        first_name: req.body.first_name,\n        family_name: req.body.family_name,\n        date_of_birth: req.body.date_of_birth,\n        date_of_death: req.body.date_of_death,\n      });\n      author.save(function (err) {\n        if (err)\n          return next(err);\n        res.redirect(author.url);\n      });\n    }\n  }\n];\n```\n</code></pre>\n<hr>\n<h2>View层</h2>\n<p>express可以指定几个模板引擎：pug、ejs等，默认采用pug，也可以采用css预处理less、sass、stylus等，默认不采用预处理器。</p>\n<p>这个项目用的pug，个人对pug较为熟悉，在此暂不记录</p>","frontmatter":{"title":"Node.js/Express入门","date":"2020-02-12","titleImage":null}}},"pageContext":{"slug":"/Node-js-Express入门/"}}}