{"componentChunkName":"component---src-template-index-tsx","path":"/post/JavaScript中new的原理及手动模拟实现/","result":{"data":{"markdownRemark":{"html":"<p>js中使用new创造的实例可以：</p>\n<ol>\n<li>访问到构造函数里的属性</li>\n<li>访问到构造函数prototype里的属性</li>\n</ol>\n<p>得到手动模拟实现new的代码：</p>\n<pre><code class=\"language-js\">function objectFactory(){\n    const argument = [...arguments];\n    let obj = new Object();\n    let Constructor = argument.shift();\n    obj.__proto__ = Constructor.prototype;\n    Constructor.apply(obj, argument);\n}\n</code></pre>\n<p>但是有一个问题，就是假如构造函数有返回值，如下例子：</p>\n<pre><code class=\"language-js\">function Otaku (name, age) {\n    this.strength = 60;\n    this.age = age;\n\n    return {\n        name: name,\n        habit: 'Games'\n    }\n}\n\nvar person = new Otaku('Kevin', '18');\n\nconsole.log(person.name) // Kevin\nconsole.log(person.habit) // Games\nconsole.log(person.strength) // undefined\nconsole.log(person.age) // undefined\n</code></pre>\n<p>在这个例子中，构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。\n如果构造函数返回的只是一个基本类型的值，则没有影响(相当于没有返回值)</p>\n<p>所以，对上面模拟new代码进行优化，返回的时候判断类型</p>\n<pre><code class=\"language-js\">function objectFactory(){\n    const argument = [...arguments];\n    let obj = new Object();\n    let Constructor = argument.shift();\n    obj.__proto__ = Constructor.prototype;\n    let ret = Constructor.apply(obj, argument);\n    return typeof ret === 'object' ? ret:obj;\n}\n</code></pre>","frontmatter":{"title":"JavaScript中new的原理及手动模拟实现","date":"2020-02-18","titleImage":null}}},"pageContext":{"slug":"/JavaScript中new的原理及手动模拟实现/"}}}