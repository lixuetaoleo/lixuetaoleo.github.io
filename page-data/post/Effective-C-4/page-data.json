{"componentChunkName":"component---src-template-index-tsx","path":"/post/Effective-C-4/","result":{"data":{"markdownRemark":{"html":"<h2>Item 10：令 operator= 返回一个reference to *this</h2>\n<ol>\n<li>在重载\"+=\"和\"=\"操作符时，应遵循返回*this的reference的“协议”(无强制性)，以应对连等情况出现。</li>\n</ol>\n<h2>Item 11：在 operator= 中处理“自我赋值”</h2>\n<ol>\n<li>注：自我赋值不但包括明显的自我赋值(如w = w)，还包括潜在的自我赋值(比如a[i] = a[j], *pi = *pj等).甚至一个指向子类对象的基类指针和子类对象指针也是自我赋值。</li>\n<li>\n<p>处理“自我赋值”的三种方案：</p>\n<p>假设如下两个类：</p>\n<pre><code>class Bitmap{...};\nclass Widget{\n  ...\nprivate:\n  Bitmap *pb;\n};\n</code></pre>\n<p>  一份不安全的operator=实现版本</p>\n<pre><code>Widget&#x26; Widget::operator=(const Widget&#x26; rhs){\n  delete pb;\n  pb = new Bitmap(*rhs.pb);\n  return *this;\n}\n</code></pre>\n<p>  这里自我赋值的问题：*this和rhs有可能是同一个对象，delete pb时可能将rhs的pb销毁。</p>\n<p>  以下是三种方案</p>\n<ul>\n<li>\n<p>传统做法：在operator=最前面加一个“证同测试(identity test)”检验：</p>\n<p>  Widget&#x26; Widget::operator=(const Widget&#x26; rhs){\nif(<em>this == &#x26;rhs) return *this;\ndelete pb;\npb = new Bitmap(</em>rhs.pb);\nreturn *this;\n}\n优点：简单，行得通</p>\n<p>缺点：无“异常安全性”，如果new Bitmap有异常，Widget会持有一个指针指向一块被删除的Bitmap，且该指针无法被删除或者安全读取。</p>\n</li>\n<li>\n<p>调整语句顺序：</p>\n<p>  Widget&#x26; Widget::operator=(const Widget&#x26; rhs){\nBitmap <em>pOrig = pb;\npb = new Bitmap(</em>rhs.pb);\ndelete pOrig;\nreturn *this;\n}\n优点：无“异常安全性”</p>\n<p>缺点：不是处理这个问题的最高效方法</p>\n</li>\n<li>\n<p>copy and swap技术：</p>\n<p>  //不具有清晰性，暂略。\n优点:</p>\n<p>缺点：</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2>Item 12：复制对象时勿忘其每一个成分</h2>\n<ol>\n<li>如果为class添加一个成员变量，必须同时修改coping函数。(同时也需修改class所有的构造函数以及任何非标准形式的operator=，如+=)</li>\n<li>\n<p>当一个类是子类并且为其撰写copying函数时，必须很小心地也复制其父类成分。由于成员变量一般是private，所以无法直接访问它们，应该让子类地copying函数调用相应地父类函数：</p>\n<ul>\n<li>构造时在member initialization list调用父类构造函数。</li>\n<li>在重载operator=时调用BaseClass::operator=(rhs);</li>\n</ul>\n</li>\n<li>\n<p>拷贝构造和拷贝赋值互相调用都是不合理的，理由如下：</p>\n<ul>\n<li>拷贝赋值操作符调用拷贝构造就像在试图构造一个已经存在的对象。</li>\n<li>拷贝构造函数不能调用拷贝赋值，因为构造函数用来初始化新对象，而赋值操作符只实行于已初始化对象身上。</li>\n</ul>\n</li>\n<li>如果发现拷贝构造和拷贝赋值中有相近代码，消除这些重复代码的做法是建立一个新的成员函数给两者调用，通常这个函数是private并且命名为init。</li>\n</ol>","frontmatter":{"title":"Effective C++ 4","date":"2019-11-06","titleImage":null}}},"pageContext":{"slug":"/Effective-C-4/"}}}