{"componentChunkName":"component---src-template-index-tsx","path":"/post/Redux总结/","result":{"data":{"markdownRemark":{"html":"<p>虽然一直在项目中用Redux，但是一直没有对Redux做一个总结，特此借此文作为自己对于理解Redux的一篇总结。</p>\n<h2>写在最前</h2>\n<p>Redux是由Facebook的Flux演变而来，并受到了函数式编程语言Elm的启发。Not only for React，任何JavaScript库都可以应用Redux。</p>\n<p>Redux的作者：Dan Abramov &#x26; </p>\n<p>Redux解决的痛点：<strong>状态管理</strong>与<strong>数据的流动与共享</strong>。</p>\n<blockquote>\n<p>你可能并不需要Redux： <a href=\"https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367\">\"You Might Not Need Redux\"</a></p>\n</blockquote>\n<h2>应用背景</h2>\n<p>在React中，数据是单向流动的，只能从父组件到子组件，如果子组件想要给父组件传递数据(props)，那么只能通过父组件传回调给子组件，然后子组件再利用回调来给父组件传数据。假设在大项目中，有非常多的组件，如下图所示，如果绿色的组件(节点)想和红色组件(节点)进行数据传递的话，将原地爆炸。</p>\n<p><img src=\"https://i.loli.net/2020/04/13/1l6jGJgtMTy7AhC.png\" alt=\"image.png\"></p>\n<p>这个时候，如果利用Redux对state进行统一管理，将很好地解决这个问题</p>\n<h2>基本用法</h2>\n<p>应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。 惟一改变 state 的办法是触发 action，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 reducers。</p>\n<p>说人话：</p>\n<p>把你去图书馆借书这一过程类比为components获取state的过程：你(components)，首先要去图书馆说\"我要借书\"(action creators)，并把这句话告诉图书馆管理员(dispatch(action))，管理员(store)收到你的请求后会带着这次action去查询记录本(reducer)，通过记录本查询到你要借的书之后把书拿回来然后交给你(返回state)，这样你就成功借到书了(components拿到state)</p>\n<p><img src=\"https://i.loli.net/2020/04/13/zwQKrJB8Nuah6nO.png\" alt=\"image.png\"></p>\n<p>下面对store, action, dispatch, reducer逐个拆解</p>\n<h3>store</h3>\n<p>store就是数据保存的地方，<strong>是redux的核心，所有的数据都要经过store，整个应用有且仅有一个 Store</strong></p>\n<p>e.g: 创建store</p>\n<pre><code class=\"language-js\">//store/index.js\nimport { createStore } from 'redux';\nconst store = createStore(fn); //传入的fn为reducer\n</code></pre>\n<h3>state</h3>\n<p>Store对象包含所有数据。如果想得到某个时刻的数据，就要对 Store 生成快照</p>\n<p>该时刻数据的集合，就叫做 State</p>\n<pre><code class=\"language-js\">const state = store.getState(); //内置API\n</code></pre>\n<h3>action</h3>\n<p>在前面提到，要想改变state，只能通过<code>dispatch(action)</code>这样的格式来进行，在这里先说action</p>\n<p>action 是一个对象。必须包括一个type属性，表示 action 的名称。其他属性可以自由设置(即state中想改变的的属性)</p>\n<pre><code class=\"language-js\">const action = {\n  type: 'ADD_TODO',\n  payload: 'Learn Redux'\n};\n</code></pre>\n<h3>actionCreators &#x26; actionTypes</h3>\n<p>由于在redux中，state的变化必须交由action，所以action如果都手写，会很麻烦，在日常开发中，可以创建一个actionCreator和actionType来解耦</p>\n<pre><code class=\"language-js\">//store/xx/actionTypes.js\nexport const ADD_TODO = '/[reducer_name]/add_todo]';\n//.. else types\n\n//store/xx/actionCreators.js\nimport * as actionTypes from './actionTypes';\n\nexport const addTodo = (text) => {\n  return {\n    type: actionTypes.ADD_TODO,\n    text\n  }}\n\n//else file\nconst action = addTodo('Learn Redux');\n</code></pre>\n<h3>dispatch</h3>\n<p>action经由dispatch发送至reducer</p>\n<pre><code class=\"language-js\">store.dispatch(addTodo('Learn Redux'));\n</code></pre>\n<h3>reducer</h3>\n<p><strong>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</strong></p>\n<pre><code class=\"language-js\">//store/reducer.js\nimport * as actionTypes from '/xx/actionTypes';\nconst defaultState = {\n    //可以设置初始状态的state\n    items:[]\n};\n\nexport default (state = defaultState, action) => {\n    switch(action.type){\n        case actionTypes.ADD_TODO:\n            return Object.assign({},state,{  //注意,不能直接改变state, 必须返回一个全新的对象\n                items: items.push(action.text)\n            });//这样写也是ok的：return { ...state, ...newState };\n        case xxx\n        default:\n            return state;\n    }\n};\n</code></pre>\n<p>Reducer 函数最重要的特征：<strong>纯函数</strong>。也就是说，<strong>只要是同样的输入，必定得到同样的输出</strong>，且需要遵守以下约束：</p>\n<ul>\n<li>不得改写参数</li>\n<li>不能调用系统 I/O 的API</li>\n<li>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</li>\n</ul>\n<p>要让store知道reducer的改变，可以利用store的subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数</p>\n<pre><code class=\"language-js\">store.subscribe(()=>{\n  let newState = store.getState();\n  component.setState(newState);   \n});\n \n //取消subscribe的方法\nlet unsubscribe = store.subscribe(()=>{\n  let newState = store.getState();\n  component.setState(newState);   \n});\n\nunsubscribe();\n</code></pre>\n<p>在一个较大的应用中，reducer可能有多个，可以把reducer进行拆分，然后进行combine再递给store</p>\n<pre><code class=\"language-js\">import {combineReducers} from 'redux';\nimport postReducer from './posts/reducer';\nimport userReducer from './users/reducer';\n\nexport default combineReducers({\n    post: postReducer, \n    user: userReducer\n});\n</code></pre>\n<h2>进阶(React-Redux与redux的中间件)</h2>\n<h3>react-redux</h3>\n<p>通过上面的redux基本用法可以看出，如果任意组件想使用store的话，就得引入store然后进行getstate，subscribe等操作，这样用起来很麻烦，可以使用官方封装的react-redux库来简化这些步骤。</p>\n<h4>基本用法</h4>\n<p>Provider组件可以使得组件拿到state</p>\n<pre><code class=\"language-js\">import React from 'react' \nimport ReactDOM from 'react-dom' \n\nimport { Provider } from 'react-redux' \nimport store from './store'\nimport App from './App' \nconst rootElement = document.getElementById('root') \nReactDOM.render( \n    &#x3C;Provider store={store}> \n        &#x3C;App /> \n    &#x3C;/Provider>, \n    rootElement \n)\n</code></pre>\n<p>connect()函数连接store与component</p>\n<pre><code class=\"language-js\">export default connect(mapStateToProps, mapDispatchToProps)(Component);\n</code></pre>\n<p>其中，mapStateToProps是一个函数。作用是建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。它返回一个对象，里面的每一个键值对就是一个映射。</p>\n<pre><code class=\"language-js\">const mapStateToProps = (state /*, ownProps*/) => { \n    return { \n        counter: state.counter\n    } \n}\n\n//之后在components里使用this.props.counter就能获取值了\n</code></pre>\n<p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p>\n<pre><code class=\"language-js\">const mapDispatchToProps = (dispatch) => ({\n    getBasicInfo(){\n        dispatch(actionCreators.getBasicInfo());\n    },\n    otherFunc(){\n        dispatch({\n            type:'XXX',\n            XXX\n        });\n    }\n});\n\n//之后在components里使用this.props.getBasicInfo or props.otherFunc就能调用派发dispatch\n</code></pre>\n<h4>with Hooks</h4>\n<p>如果在functional components中要使用两个map，可以用useSelector和useDispatch两个hooks来实现相应的功能。</p>\n<pre><code class=\"language-js\">//mapStateToProps\nimport {useSelector, useDispatch} from 'react-redux';\n\nconst counter = useSelector(state.counter);\n\n//mapDispatchToProps\nconst dispatch = useDispatch();\n\ndispatch(actionCreators.getBasicInfo());\n</code></pre>\n<h3>使用中间件以及异步处理</h3>\n<p>关于以上内容，你可能注意到了，dispatch只能传对象，如果state的某项数据需要先从后台获取再改变怎么办呢？可以使用中间件来使得dispatch有异步处理能力</p>\n<p>这里列举的是最常用的redux中间件之一--redux-thunk</p>\n<pre><code class=\"language-js\">import thunk from 'redux-thunk'\n\nconst store = createStore( reducer, /*initial_state*/, applyMiddleware(thunk));//初始状态可选\n</code></pre>\n<p>加载redux-thunk中间件以后，dispatch就有了异步能力了，原理请参考'源码剖析'部分，这里先放上异步dispatch用法</p>\n<pre><code class=\"language-js\">export const getBasicInfo = () => {\n  return (dispatch) => {\n    axios.get('/api/userinfo.json').then((res) => {\n      console.log(res);\n      const result = res.data.data;\n      const action = {\n        type: actionTypes.GET_BASIC_INFO,\n        name: result.name,\n        quote: result.quote\n      };\n      dispatch(action);\n    });\n  };\n};\n</code></pre>\n<p>可以看到actionCreator返回的是一个函数而不是之前的对象了，这个函数接收一个dispatch参数，然后在做完异步处理后最后进行dispatch的派发交给reducer</p>\n<h2>useReducer与Context</h2>\n<h2>React Redux源码剖析</h2>\n<h2>参考文献</h2>\n<p><a href=\"https://redux.js.org/introduction/getting-started\">Getting Started with Redux</a>\n<a href=\"https://react-redux.js.org/introduction\">React Redux</a>\n<a href=\"http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html\">Redux 入门教程--阮一峰</a></p>\n<hr>\n<p>(全文未完待续...)</p>","frontmatter":{"title":"Redux总结","date":"2020-04-13","titleImage":null}}},"pageContext":{"slug":"/Redux总结/"}}}