{"componentChunkName":"component---src-template-index-tsx","path":"/post/Effective-C-7/","result":{"data":{"markdownRemark":{"html":"<h2>Item 23：宁以non-member、non-friend替换member函数</h2>\n<ol>\n<li>封装性的“粗糙测量”：愈多函数可访问对象内的数据，数据的封装性就愈低</li>\n<li>由上一条，member函数的封装性比non-member函数低。</li>\n<li>友元函数对class private成员的访问权力与member函数相同，因此两者对封装的冲击力度也相同。</li>\n<li>只因在意封装性而让函数“成为class的non-member”并不意味它“不可以是另一个class的member”。可以令这些函数称为一个工具类的static member函数，只要它不是其类的一部分（或者friend），就不会印象该类private成员的封装性。</li>\n<li>\n<p>更一般地做法是把这些non-member函数与它需要的那个类放在同一个namespace下</p>\n<pre><code>namespace WebBrowserStuff{\n    class WebBrowser{...};\n    void clearBrowser(WebBrowser &#x26;wb);\n    ...\n}\n</code></pre>\n</li>\n<li>将所有便利函数放在多个头文件内但隶属于同一个namespace，意味着可以轻松扩展这一组便利函数。比如STL做法就是这样。</li>\n</ol>\n<h1>Item 24：若所有参数皆需类型转换，请为此采用non-member函数</h1>\n<p>假如有一个表示有理数的类，并且其对operator*进行了重载，如下：</p>\n<pre><code>class Rational{\npublic:\n    Rational(int numerator = 0, int denominator = 1); //构造函数可以不为explicit，以允许int to Rational隐式转换。\n    int numerator() const;\n    int denominator() const;\n    const Rational operator* (const Rational&#x26; rhs) const;\nprivate:\n    ...\n};\n</code></pre>\n<p>这样设计对两个Rational对象是没问题的。</p>\n<p>但是如果要支持混合运算，即将ints和Rationals相乘</p>\n<p>result = objOFRational * 2; //work</p>\n<p>result = 2 * objOFRational; //wrong!</p>\n<p>错误的原因是因为2没有对应的类，也没有对应的operator<em>，此时编译器查找non-member operator</em>，也没有一个接受int和Rational作为参数的non-member operator*，因此失败。</p>\n<p>前面那一行正确的原因是因为发生了隐式转换。</p>\n<p>因此只要设计一个non-member，non-friend(non-friend的原因是因为这个函数只需要public接口)的operator*即可。</p>\n<pre><code>const Rational operator*(const Rational&#x26; lhs, const Rational&#x26; rhs){\n    return Rational(lhs.numerator()*rhs.numerator(), lhs.denominator() * rhs.denominator());\n}\n</code></pre>\n<ol>\n<li>一个重要的观察：member函数的反面是non-member函数，而非friend函数。</li>\n<li>无论何时如果可以避免friend函数就应该避免，就像在真实世界中，朋友带来的麻烦多于价值(hah)。</li>\n</ol>\n<h1>Item 25：考虑写出一个不抛异常的swap函数</h1>\n<p>假设你有一个“pimpl(pointer to implementation)手法”写的对象，如下所示：</p>\n<pre><code>class Widget{\npublic:\n    Widget(const Widget&#x26; rhs);\n    Widget&#x26; operator=(const Widget&#x26; rhs){\n        ...\n        *pImpl = *(rhs.pImpl);\n        ...\n    }\n    ...\nprivate:\n    WidgetImpl* pImpl; //指针，所指对象内含Widget数据。\n};\n</code></pre>\n<p>对于该类，要交换两个Widget对象的值，做法是交换pImpl指针，但是std::swap的做法是平淡的(即利用tmp来进行置换)，因此一种做法是针对Widget将std::swap特化。</p>\n<p>步骤：</p>\n<ol>\n<li>提供一个public swap成员函数，让其高效的置换类型的两个对象值，并且这个函数<code>绝不该抛出异常</code></li>\n<li>在class或template所在的命名空间内提供一个non-member swap，并令它调用上述swap成员函数。</li>\n<li>如果正编写一个class（而非class template），为class特化std::swap，并令它调用swap成员函数。</li>\n<li>最后，如果你调用swap，请确定包含一个using声明符，以便让std::swap在你的函数内曝光可见，然后不加任何namespace修饰符，赤裸裸地调用swap。</li>\n</ol>\n<p>注：C++只允许对class模板偏特化，函数模板不能。</p>","frontmatter":{"title":"Effective C++ 7","date":"2019-11-13","titleImage":null}}},"pageContext":{"slug":"/Effective-C-7/"}}}