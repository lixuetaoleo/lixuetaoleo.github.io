{"componentChunkName":"component---src-template-index-tsx","path":"/post/CSS居中的方式/","result":{"data":{"markdownRemark":{"html":"<p>preference(translate)：<a href=\"https://css-tricks.com/centering-css-complete-guide\">Centering in CSS: A Complete Guide</a></p>\n<hr>\n<h3>引言</h3>\n<p>在CSS中，居中是很烦的一件事，并不是因为它很难做，而是有很多不同的方法去做，很难选择。</p>\n<h3>方法</h3>\n<h4>水平居中</h4>\n<ol>\n<li>\n<p>内联元素(比如文本或者链接)</p>\n<p>在块级父元素内将行内元素水平居中，只需text-align: center。</p>\n<p>inline, inline-block, inline-table, inline-flex都适用</p>\n</li>\n<li>\n<p>块级元素</p>\n<p>将块级元素的margin-left和margin-right设置为auto(并且该块级元素设置了width属性，否则它将是全宽度，并不需要居中了)</p>\n<p>通常做法：</p>\n<pre><code>.center-me { \n   margin: 0 auto; \n   width: ???px;\n}\n</code></pre>\n<p>无论居中的块级元素或父级元素的宽度如何，它都将起作用。</p>\n<p>注意：不能将元素<em>float</em>至居中</p>\n</li>\n<li>\n<p>多个块级元素</p>\n<p>如果有两个或以上的块级元素需要以行排列方式居中，最好为它们设置不同的display类型</p>\n<ul>\n<li>\n<p>inline-block</p>\n<pre><code>.inline-block-center {  \n    text-align: center;\n}\n.inline-block-center div {\n    display: inline-block;  \n    text-align: left;\n}\n</code></pre>\n</li>\n<li>\n<p>flex</p>\n<pre><code>.flex-center {\n    display: flex;\n    justify-content: center;\n}\n</code></pre>\n<p>多个块级元素按列居中，可以参考块级元素的方法(为这几个块级元素都设置宽度)</p>\n<pre><code>main div {              \n    margin: 0 auto;\n    padding: 15px;\n    margin: 5px auto;\n}\nmain div:nth-child(1) {\n    width: 200px;}\nmain div:nth-child(2) {\n    width: 400px;\n}\nmain div:nth-child(3) { \n    width: 125px;\n}\n    \n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h4>垂直居中</h4>\n<p>垂直居中就比较棘手了</p>\n<ol>\n<li>\n<p>内联元素(文本或者链接)</p>\n<ul>\n<li>\n<p>单行</p>\n<p>有时候inline/text元素表现为垂直居中，只是因为它们的padding-top和padding-bottom相同</p>\n<p>如果某些原因，padding-top和bottom不能设置，可以用一个trick来使文本垂直居中,trick就是设置相同的height和line-height：</p>\n<p>   .center-text-trick {\nheight: 100px;\nline-height: 100px;\nwhite-space: nowrap;\n}</p>\n</li>\n<li>\n<p>多行</p>\n<p>多行也可以为文本设置相同的padding-top和padding-bottom使其垂直居中</p>\n<p>如果这种方法不work，那么可能text是一个表格单元格(可能是HTML中设置了表格，也有可能是在css中写成了表格)。此时用vertic-align:middle可以解决这个问题</p>\n<p>如果不是表格而是一个container里的文字，可以使用flexbox,可以很容易地使单个flex-child集中在flex-parent中。通常将flex-parent写成如下形式：\n注意parent必须要有height</p>\n<pre><code>.flex-center-vertically {\n    display: flex; \n    justify-content: center;\n    flex-direction: column; \n    height: 400px; \n}\n</code></pre>\n<p>如果前两种方法都不ok，采用“ghost element”的技术</p>\n   <div class=\"ghost-center\">  \n        <p>\n             I'm vertically centered multiple lines of text in a container. Centered with a ghost pseudo element\n        </p>\n   </div>\n   \n   .ghost-center \n   { \n        position: relative; \n   } \n   \n   .ghost-center::before {\n        content: \" \"; \n        display: inline-block;\n        height: 100%;\n        width: 1%;\n        vertical-align: middle;\n   }\n   \n   .ghost-center p\n   { \n        display: inline-block; \n        vertical-align: middle;\n   }\n</li>\n</ul>\n</li>\n<li>\n<p>块级元素</p>\n<ul>\n<li>\n<p>已知高度\n在网页布局中，通常高度是未知的，比如：宽度改变导致文本重排；改变文本中的样式会改变高度；文本量的改变会改变高度；具有固定宽高比的元素(比如图片等)在resize的时候会改变高度。\n但如果确实能获取高度的话，可以用以下方法进行垂直居中：</p>\n<pre><code>.parent { \n    position: relative; \n} \n.child { \n    position: absolute; \n    top: 50%; \n    height: 100px; \n    margin-top: -50px; // account for padding and border if not using box-sizing: border-box; \n}\n</code></pre>\n</li>\n<li>\n<p>未知高度\n利用子块布局到父块一半的高度然后再“抬升”一半进行垂直居中    </p>\n<pre><code>.parent {\n    position: relative; \n} \n.child {\n    position: absolute;\n    top: 50%; \n    transform: translateY(-50%); \n}\n</code></pre>\n</li>\n<li>\n<p>如果不介意元素会把容器的高度拉高</p>\n<p>利用table</p>\n<pre><code>main { \n    background: white;\n    height: 300px;\n    margin: 20px; \n    width: 300px;\n    position: relative;\n    padding: 20px;\n    display: table;\n}\nmain div {\n    background: black; \n    color: white;  \n    padding: 20px; \n    display: table-cell; \n    vertical-align: middle;\n}\n</code></pre>\n</li>\n<li>\n<p>利用flexbox</p>\n<p>不要过于惊讶，利用flexbox会简单许多，方法</p>\n<pre><code>.parent-container { \n    display: flex; \n    flex-direction: column;\n    justify-content: center;\n}\n</code></pre>\n<p>或者</p>\n<pre><code>.parent-container { \n    display: flex; \n}\n.child-container{\n    margin:auto;\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<h4>混合式居中(水平+垂直)</h4>\n<p>可以组合上面提到的水平居中和垂直居中方法来进行混合式居中，但是通常可以将混合式居中分为以下三个阵营</p>\n<ol>\n<li>\n<p>元素的宽高固定</p>\n<p>把子块top和left定位50%后利用宽高一半的“负margin”，这种方式有着很好的跨浏览器支持</p>\n<pre><code>.parent {\n    position: relative; \n} \n.child {\n    width: 300px; \n    height: 100px; \n    padding: 20px; \n    position: absolute;\n    top: 50%; \n    left: 50%; \n    margin: -70px 0 0 -170px;\n}\n</code></pre>\n</li>\n<li>\n<p>元素宽高未知</p>\n<p>如果未知元素的宽高，用transform属性在两个方向（基于元素的当前宽度/高度）上进行负平移50％：</p>\n<pre><code>.parent { \n    position: relative; \n} \n.child { \n    position: absolute; \n    top: 50%; \n    left: 50%; \n    transform: translate(-50%, -50%); \n}\n</code></pre>\n</li>\n<li>\n<p>如果可以用flexbox</p>\n<p>对于flexbox，如果要进行混合居中，只需利用两个居中属性</p>\n<pre><code>.parent {\n    display: flex; \n    justify-content: center; \n    align-items: center;\n}\n</code></pre>\n</li>\n<li>\n<p>如果可以利用grid</p>\n<p>这种方式只是一种trick，对于一个元素很适用</p>\n<pre><code>body, html { height: 100%; \n    display: grid;\n} \nspan { /* thing to center */ \n    margin: auto; \n}\n</code></pre>\n</li>\n</ol>\n<h4>总结</h4>\n<p>完全利用css进行居中是可行的</p>","frontmatter":{"title":"CSS居中的方式","date":"2019-12-12","titleImage":null}}},"pageContext":{"slug":"/CSS居中的方式/"}}}